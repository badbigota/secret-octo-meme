% !TeX encoding = utf8
% !TeX program = pdflatex
% !TeXpellcheck = it_IT

\documentclass[a4paper,11pt,oneside]{article} 

\usepackage{relazioni}
\usepackage{imakeidx}
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{blindtext}
\usepackage{titletoc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{geometry}
\usepackage{array}
\usepackage[export]{adjustbox}
\usepackage{multirow}
\usepackage{multicol}
\hypersetup{
%    colorlinks=false,
}


\def\titolo{Esperienza guidovia}
\def\dataconsegna{20 Gennaio 2020}

\graphicspath{{Figure/}}

\begin{document}
\input{Front-matter/Frontespizio}

\tableofcontents
\addtocontents{toc}{~\hfill{Pagina}\par}
\contentsmargin{6em}
\dottedcontents{section}[1em]{\bigskip}{2em}{1pc}
\dottedcontents{subsection}[3em]{\smallskip}{3em}{1pc}
\dottedcontents{subsubsection}[5em]{\smallskip}{4em}{1pc}


\newpage

\section{Obiettivo}
L'obiettivo dell'esperienza è ottenere la miglior stima dell'accelerazione di gravità a Padova, studiando il moto di una slitta su un piano inclinato.

\section{Apparato sperimentale}\label{section:apparato}

\begin{figure}[h!]
    \centering
    \includegraphics[width= 10cm]{DiagrammaApparato.jpg}
    \caption{Diagramma composizione apparato}
    \label{fig:apparato_sperimentale}
\end{figure}

Per lo svolgimento dell'esperienza si è fatto uso di:
\begin{enumerate}
    \item Una slitta in plexiglas rettangolare con delle sporgenze sulla parte inferiore al fine di agevolarne lo scorrimento sul piano inclinato. La slitta è eventualmente equipaggiabile con dischi di ottone per aumentarne la massa.
    \item Una guida in alluminio a sezione rettangolare e a inclinazione variabile (tramite una vite) sulla quale far scorrere la slitta. La guida è inoltre forata strategicamente su tutta la sua lunghezza per permettere l'uscita dell'aria erogata da un soffiatore a pressione regolabile. Ciò premette la conseguente formazione di un cuscino d'aria sotto la slitta durante la sua corsa al fine di eliminare il contributo dell'attrito radente.
    \item Un cronometro digitale avente sensibilità di $S=\num{1e4} \si{s^{-1}}$.
    \item Traguardi a sensori a infrarossi posizionati perpendicolarmente alla guida per delimitare una qualsiasi porzione di spazio sulla stessa e utilizzati per azionare e fermare il cronometro al passaggio della slitta. In particolare il primo permetteva l'inizio del conteggio, fermato poi dal passaggio della slitta al secondo traguardo.
    \item Elettrocalamita posta all'inizio della guida, utilizzata nella prima parte dell'esperienza per bloccare la slitta al fine di rilasciarla. Nella seconda parte è usata per imprimere una forza repulsiva alla slitta stessa. L'elettrocalamita è azionabile manualmente da un operatore.
    \item Spessori di alluminio utilizzati per ridurre la spinta impressa dall'elettrocalamita, interponibili tra quest'ultima e la slitta.
\end{enumerate}

\section{Metodo}
\subsection{Orizzontalità della guida}
La fase preliminare dell'esperienza prevede di determinare l'orizzontalità della guida tramite misurazioni dirette. La procedura impiegata consiste nel verificare se la slitta rimane stabile in 3 punti differenti, a 40 \si{cm}, 80 \si{cm} e 110 \si{cm} dall'origine della guida.\\
In primo luogo si è proceduto con l'accensione del soffiatore, impostato per tutta l'esperienza alla stessa potenza, per poi posizionare la slitta nel primo punto, a 40cm. Si è poi regolata la vite affinché la slitta rimanesse stabile al fine di poter fissare un sistema di riferimento con il quale testare l'orizzontalità sugli altri due punti. Lasciando invariato il sistema di riferimento sono stati annotati i valori sulla vite per i quali, nel secondo  e nel terzo punto, la slitta rimane stabile.\\
Ipotizzando l'imprecisione delle misure precedentemente effettuate si è ripetuto il procedimento e si è verificato che per il secondo e per il terzo punto il risultato rimaneva invariato, invece per il primo punto si è misurato un nuovo valore. Data l'ipotesi, si è calcolata la media e la deviazione standard della media su queste ultime 3 misure effettuate.\\
La seguente tabella riporta i dati ottenuti:

\begin{table}[h!]
    \centering
    \caption{Valori per l'orizzontalità della guida \\ Unità di misura: quarti di giro di vite}
\begin{tabular}{ccc|cc}
    \toprule
    $\alpha_{0}$&$\alpha_{2}$&$\alpha_{3}$&$\overline{\alpha}$&$\sigma_{\overline{\alpha}}$\\
    \midrule
    0.15&0.15&0.40&0.23&0.08\\
    \bottomrule
    \end{tabular}
    \label{tab:guida_orizzontale}
\end{table}

Si è poi è assunto come zero del nuovo sistema di riferimento, la media delle misure $\overline{\alpha} \pm \sigma_{\overline{\alpha}}$, settando la ghiera.\\

\subsection{Presa dati prima esperienza}
Fissato il sistema di riferimento si è impostata la guida ad un'inclinazione di $15'$ ruotando 3 volte la vite, in quanto ciascun giro corrisponde ad una variazione  di $5'$.\\

Si sono posizionati i traguardi, inizialmente a 40cm e 50cm e, successivamente, lasciando invariata la posizione del primo, si è spostato solo il secondo di 10cm per volta fino ad arrivare a 110cm. \\
Per ciascun intervallo di spazio ([40cm,50cm], [40cm,60cm], \dots [40cm,110cm]) si sono prese 5 misure ripetute di intervalli di tempo, ognuna delle quali rappresentava il tempo impiegato dalla slitta per percorrere il relativo spazio.\\  
Il cronometro è stato impostato per entrambe le esperienze alla sensibilità di $S=\num{1e4} \si{s^{-1}}$, in modo da rendere più accurata la successiva analisi.\\
Si è ripetuta la medesima operazione di presa dati variando l'inclinazione della slitta a 30' e successivamente a 45'.
Infine, operando sempre sulla slitta inclinata di 45', si è caricata la slitta con un disco di ottone al fine di incrementarne la massa.

\subsection{Presa dati seconda esperienza}
Si è portata la guida all'orizzontalità e l'elettrocalamita è stata configurata per imprimere una spinta alla slitta priva della massa di ottone. Ciò ha consentito alla slitta di procedere lungo la guida, rallentando per le forze d'attrito viscoso dell'aria, oggetto di analisi in questa seconda esperienza.\\
I traguardi sono stati posizionati rispettivamente a 40cm e 60cm, per poi modificarne la distanza dall'origine aumentandola di 10 cm per volta arrivando fino all'intervallo 90-110cm e, per ogni intervallo di spazio sono state prese 5 misurazioni temporali.\\
Si è poi ripetuto il procedimento e la conseguente presa dati, una volta con la slitta carica e una seconda volta con la slitta scarica utilizzando uno spessore di alluminio interposto tra quest'ultima e l'elettrocalamita.

\section{Analisi dati}
\subsection{Prima esperienza}
Si sono dapprima analizzate le misurazioni relative alla guida inclinata di 15' seguendo il procedimento riportato in seguito.\\
Per ciascun intervallo di spazio ([40cm, 50cm], [40cm, 60cm], \dots [40cm, 110cm]) si è calcolata  la media $\overline{t}$, il suo relativo errore $\sigma_{\overline{t}}$ e la deviazione standard $\sigma$. Inoltre si sono calcolate le semisomme dei tempi medi tra coppie di intervalli consecutivi, ai quali d'ora in avanti si farà riferimento con il termine \textit{tempi intermedi}, e gli errori ad essi associati tramite la formula di propagazione degli errori (\ref{eq:}).
I dati ottenuti sono riportati nella Tabella \ref{tab:15_primi}.

\begin{figure}[h!]
    \centering
    \subfloat[Medie tempi a 15']{
        \label{tab:15_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\
        \midrule
        40 & 50  & 0.642 & 0.003 & 0.001 \\
        40 & 60  & 1.191 & 0.002 & 0.001 \\
        40 & 70  & 1.692 & 0.005 & 0.002 \\
        40 & 80  & 2.143 & 0.009 & 0.004 \\
        40 & 90  & 2.557 & 0.008 & 0.003 \\
        40 & 100 & 2.944 & 0.003 & 0.001 \\
        40 & 110 & 3.315 & 0.006 & 0.002\\
        \bottomrule
    \end{tabular}
    \hspace{0.7cm}
    }
    \subfloat[Medie tempi a 30']{
        \label{tab:30_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\
        \midrule
        40 & 50  & 0.4528 & 0.0008 & 0.0003 \\
        40 & 60  & 0.8434 & 0.001  & 0.0007 \\
        40 & 70  & 1.1920 & 0.001  & 0.0006 \\
        40 & 80  & 1.513 & 0.002  & 0.001  \\
        40 & 90  & 1.8019 & 0.001  & 0.0007 \\
        40 & 100 & 2.0811 & 0.002  & 0.0009 \\
        40 & 110 & 2.338  & 0.002  & 0.001 \\
        \bottomrule
        \end{tabular}
    }
    \newline
    \subfloat[Medie tempi a 45']{
        \label{tab:45_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\
        \midrule
        40 & 50  & 0.3697  & 0.0004 & 0.0002 \\
        40 & 60  & 0.6892 & 0.001  & 0.0004 \\
        40 & 70  & 0.9755 & 0.001  & 0.0006 \\
        40 & 80  & 1.2364 & 0.0008 & 0.0003 \\
        40 & 90  & 1.4777 & 0.001  & 0.0007 \\
        40 & 100 & 1.7026 & 0.0009 & 0.0004 \\
        40 & 110 & 1.913 & 0.002  & 0.001 \\
        \bottomrule
    \end{tabular}
    \hspace{0.7cm}
    }
    \subfloat[Medie tempi a 45' con massa]{
        \label{tab:d45_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\\midrule
        40 & 50  & 0.37292 & 0.0002 & 0.00009 \\
        40 & 60  & 0.6915  & 0.0006 & 0.0002 \\
        40 & 70  & 0.9782 & 0.0003 & 0.0001 \\
        40 & 80  & 1.2389 & 0.001  & 0.0005 \\
        40 & 90  & 1.4787  & 0.001   & 0.0004 \\
        40 & 100 & 1.7025 & 0.0003 & 0.0001 \\
        40 & 110 & 1.9118 & 0.001  & 0.0005 \\
        \bottomrule
        \end{tabular}
    }
    \newline
    \caption{Medie tempi e deviazioni standard}
\end{figure}


Si è proceduto con il calcolo della velocità media per ogni intervallo di spazio di 10cm, partendo dall'intervallo [40cm,50cm] e terminando con l'intervallo [100cm,110cm] utilizzando la seguente formula:
\begin{equation*}
    \overline{v_{(x_i;x_{i+1})}}=\frac{x_{i+1}-x_i}{t(40;x_{i+1})-t(40;x_i)}
\end{equation*}
assumendo come valori di $x_i$ tutti i possibili estremi degli intervalli considerati, ovvero 40cm, 50cm, 60cm, ... , 110cm.
\newpage
Utilizzando la formula di propagazione degli errori si è poi calcolato l'errore casuale della velocità media per ogni intervallo, assumendo come errore sul tempo la deviazione standard della media di ciascun intervallo precedentemente calcolato, e come errore sullo spazio la deviazione standard relativa alla distribuzione triangolare, utilizzando le seguenti:

\begin{equation*}%Distrib triang
\sigma_{x}=\frac{\mathopen|2\Delta x\mathclose|}{\sqrt{24}} 
\end{equation*}

\begin{equation*}
\label{eq:propagazione_velocità}
    \sigma_{v}= \sqrt{
   \left( {\frac{\partial v}{\partial x_{i}}} \Big|_{\ast}\right)^{2} \cdot \sigma_{x_{i}}^2  +   
   \left( {\frac{\partial v}{\partial x_{i+1}}}\Big|_{\ast}\right )^{2} \cdot \sigma_{x_{i+1}}^2   +   
   \left( {\frac{\partial v}{\partial t_{\left(40; x_{i+1}\right)}}}\Big|_{\ast}\right)^{2}  \cdot \sigma_{t_{\left(40; x_{i+1}\right)}}^2 +   
       \left( {\frac{\partial v}{\partial t_{\left(40; x_i\right)}}}\Big|_{\ast}\right)^{2} \cdot  \sigma_{t_{\left(40; x_i\right)}}^2
    }
\end{equation*}

Dove $2\Delta x$ è la più piccola tacca di misura leggibile dall'operatore sulla stecca metrica.\\
Le coppie $(t_{intermedio}, v_{media})$ precedentemente calcolate sono state utilizzate come coordinate di punti su un piano cartesiano, e si è ricercata una loro interpolazione lineare sfruttando il metodo del minimo ${\chi}^2$, ottenendo il coefficiente angolare $b$, corrispondente alla componente dell'accelerazione di gravità $g_{0}$ sulla parallela alla guidovia, e l'intercetta della retta cercata, corrispondente alla velocità della slitta nella posizione iniziale, 40cm.\\
Per stimare $g_{0}$ è stato sufficiente dividere il coefficiente angolare della retta per il seno dell'angolo di inclinazione della guida.
Per il computo di $ \sigma_{g_{0}}$ si è scelto di calcolare l'errore relativo all'angolo propagando gli errori dell'orizzontalità (Tabella \ref{tab:guida_orizzontale}) e l'errore derivante dalla distribuzione triangolare per l'incertezza del posizionamento a 15', il valore ottenuto risulta essere $0.1'$. L'errore relativo a $\sigma_b$  si è ricavato invece dal metodo del minimo ${\chi}^2$ per poi propagare $\sigma_b$ e $\sigma_{\alpha}$ tramite la formula \ref{}. Si è proceduto infine con il calcolo della compatibilità $\lambda$ delle 4 stime dell'accelerazione di gravità $g_{0}$ relative ai 4 differenti campioni con $g_{PD}=(9.801\pm 0.001)\si{m/s^2}$ stimata a Padova. Si è fatto riferimento alle seguenti per valutare $\lambda$ e la sua bontà:
\begin{equation*}%Comp
    \label{eq:cases}
    \begin{cases}
    0<\lambda\leq 1, & \text{Ottima}\\
    1<\lambda\leq2, & \text{Discreta}\\
    2<\lambda\leq3, & \text{Pessima}\\
    3<\lambda, & \text{Non compatibile}\\
    \end{cases}
\end{equation*}

In seguito tutto il procedimento è stato ripetuto variando l'inclinazione della guida portandola dapprima a 30', poi a 45' ed infine mantenendo l'inclinazione della guida a 45' si è aumentata la massa della slitta con un disco di ottone.\\

\begin{table}[h!]%b g_0 e comp
    \centering
    \begin{tabular}{r|c|c|c|c}
    \toprule
    & \textbf{15'} & \textbf{30'} & \textbf{45'} & \textbf{45' con Massa}\\
    \midrule
         \textbf{Accelerazione slitta $[\si{m/s^2}]$} & $0.04\pm0.01$    & $0.08\pm0.03$   & $0.12\pm0.05$    & $0.12\pm0.05$\\
        \textbf{Gravità $[\si{m/s^2}]$}       & $9.4\pm0.2$ & $9.5\pm0.2$ & $9.51\pm0.06$ & $9.7\pm0.1$ \\
        \textbf{Compatibilità $\lambda$} &1.7 &0.76 &4.3 &0.11\\
        \bottomrule
    \end{tabular}
    \caption{Stime di accelerazione $b\pm \sigma_{b}$, di gravità $g_{0} \pm \sigma_{g_{0}}$ e relativa compatibilità $\lambda$ con $g_{PD}$}
    \label{tab:stima_b_g}
\end{table}

\bigskip
In seguito vengono riportati i grafici affiancati dalle relative tabelle riguardanti le velocità calcolate:
\bigskip
\bigskip

\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 15'}
    \subfloat[Interpolazione lineare a 15']{
        \label{fig:g_0_15}
        \includegraphics[width=8.2cm]{15primi.png}
    }
    \subfloat[Medie e deviazioni standard a 15']{
    \label{tab:15primi}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.321 & 0.001 & 0.1557 & 0.0009 \\
    0.916 & 0.001 & 0.181 & 0.001 \\
    1.442 & 0.002 & 0.199 & 0.001 \\
    1.917 & 0.004 & 0.221 & 0.002 \\
    2.350 & 0.005 & 0.241 & 0.003 \\
    2.751 & 0.004 & 0.258 & 0.003 \\
    3.130 & 0.003 & 0.269 & 0.002 \\ 
    \bottomrule
    \end{tabular}
    }
\end{figure}


\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 30'}
    \subfloat[Interpolazione lineare a 30']{
    \label{fig:g_0_30}
           \includegraphics[width=8.2cm]{30primi.png}
    }
    \subfloat[Medie e deviazioni standard a 30']{
    \label{tab:30primi}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.2264 & 0.0003 & 0.220 & 0.001 \\
    0.6481 & 0.0008 & 0.256 & 0.001 \\
    1.017 & 0.001 & 0.286 & 0.001 \\
    1.352 & 0.001 & 0.311 & 0.002 \\
    1.657 & 0.001 & 0.346 & 0.002 \\
    1.941 & 0.001 & 0.358 & 0.002 \\
    2.209 & 0.001 & 0.388 & 0.003 \\
    \bottomrule
\end{tabular}
}
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 45'}
    \subfloat[Interpolazione lineare a 45']{
    \label{fig:g_0_45}
           \includegraphics[width=8.2cm]{45_primi.png}
    }
    \subfloat[Medie e deviazioni standard a 45']{
    \label{tab:45primi}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.18485 & 0.0002 & 0.270 & 0.001 \\
    0.52946 & 0.0005 & 0.312 & 0.001 \\ 
    0.83239 & 0.0007 & 0.349 & 0.002 \\ 
    1.10599 & 0.0007 & 0.383 & 0.002 \\ 
    1.35709 & 0.0008 & 0.414 & 0.002 \\
    1.5902 & 0.0008 & 0.444 & 0.003 \\
    1.808 & 0.001 & 0.473 & 0.003 \\
    \bottomrule
    \end{tabular}
    }
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 45' con massa}
    \subfloat[Interpolazione lineare a 45' con massa]{
    \label{fig:g_0_p45}
           \includegraphics[width=8.2cm]{45_primip.png}
    }
    \subfloat[Medie e dev. standard a 45' con massa]{
    \label{tab:45primi_p}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.18646 & 0.00009 & 0.268 & 0.001 \\
    0.5322 & 0.0003 & 0.313 & 0.001 \\
    0.8348 & 0.0003 & 0.348 & 0.002 \\
    1.1086 & 0.0006 & 0.383 & 0.002 \\
    1.3588 & 0.0007 & 0.417 & 0.002 \\
    1.5906 & 0.0004 & 0.446 & 0.002 \\
    1.8072 & 0.0006 & 0.477 & 0.003 \\
    \bottomrule
\end{tabular}
}
\end{figure}
\newpage
\subsection{Seconda esperienza}
In primo luogo sono stati analizzati i valori derivanti dalle misurazioni ottenute con la slitta scarica e senza spessore di alluminio per ciascun segmento di 20cm ([40cm,60cm], [50cm,70cm], ...) al fine di calcolare media $\overline{t}$, la deviazione standard $\sigma$ e la deviazione standard della media $\sigma_{\overline{t}}$ dei tempi impiegati per percorrere la distanza fra i traguardi.\\

\begin{table}[h!]%NM_NA
\centering
\begin{tabular}{c|ccc}
\toprule
$x_{intermedio}$&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
$[\si{cm}]$&$[\si{s}]$&$[\si{s}]$&$[\si{s}]$\\
\midrule
50	&1.469	&0.01	&0.006\\
60	&1.486	    &0.01	&0.006\\
70	&1.50	&0.02	&0.01\\
80	&1.501	&0.01	&0.008\\
90	&1.493	&0.003	&0.001\\
100	&1.51	&0.03	&0.01\\
\bottomrule
\end{tabular}
    \caption{Medie tempi della slitta scarica senza spessore di alluminio}
    \label{tab:nm_na}
\end{table}

\begin{table}[h!]%SM_NA
\centering
\begin{tabular}{c|ccc}
\toprule
$x_{intermedio}$&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
$[\si{cm}]$&$[\si{s}]$&$[\si{s}]$&$[\si{s}]$\\
\midrule
50	&2.295 	&0.01	&0.008\\
60	&2.35	&0.02	&0.01\\
70	&2.391	&0.02	&0.009\\
80	&2.46     &0.04	&0.02\\
90  &2.58	&0.05	&0.02\\
100	&2.67	&0.07	&0.03\\
\bottomrule
\end{tabular}
    \caption{Medie tempi della slitta carica senza alluminio}
    \label{tab:sm_na}
\end{table}

\begin{table}[h!]%NM_SA
\centering
\begin{tabular}{c|ccc}
\toprule
$x_{intermedio}$&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
$[\si{cm}]$&$[\si{s}]$&$[\si{s}]$&$[\si{s}]$\\
\midrule
50	&1.87	&0.03	&0.01\\
60	&1.915	&0.01	&0.006\\
70	&1.90	&0.02	&0.01\\
80	&1.864	&0.01	&0.008\\
90	&1.86	&0.03	&0.01\\
100	&1.94	    &0.08	&0.03\\
\bottomrule
\end{tabular}
    \caption{Medie tempi della slitta scarica con alluminio}
    \label{tab:nm_sa}
\end{table}


In seguito sono state calcolate le velocità medie di percorrenza $\overline{v}$ di ciascun tratto e il loro relativo errore tramite la formula di propagazione degli errori, assumendo come errore sullo spazio la deviazione standard relativa alla distribuzione triangolare, per le medesime motivazioni date nella prima esperienza.\\


\begin{figure}[h!]
    \centering 
    \caption{Interpolazione lineare dati ottenuti con slitta scarica senza alluminio}
    \subfloat[Grafico]{
    \label{fig:nm_na.png} \includegraphics[width=9.8cm]{nm_na.png}
    }
    \subfloat[Tabella]{
    \begin{tabular}{c|cc}
    \toprule
        $x_{intermedio}$&$\overline{v}$&$\sigma_{\overline{v}}$\\
        $[\si{cm}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
        50 & 0.1361 & 0.0006\\
        60 & 0.1345 & 0.0006\\
        70 & 0.133 & 0.001\\
        80 & 0.1331 & 0.0008\\
        90 & 0.1338 & 0.0002\\
        100 & 0.131 & 0.001\\
    \bottomrule
    \end{tabular}
    \label{tab:vel_nm_na}
    }
\end{figure}
\begin{figure}[h!]
    \centering
    \caption{Interpolazione lineare dati ottenuti con slitta scarica e alluminio}
    \subfloat[Grafico]{
    \label{fig:nm_sa.png}
           \includegraphics[width=9.8cm]{nm_sa.png}
    }
    \subfloat[Tabella]{
        \begin{tabular}{c|cc}
    \toprule
        $x_{intermedio}$&$\overline{v}$&$\sigma_{\overline{v}}$\\
        $[\si{cm}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
        50 & 0.1066 & 0.0007\\
        60 & 0.1044 & 0.0003\\
        70 & 0.1047 & 0.0006\\
        80 & 0.1072 & 0.0005\\
        90 & 0.107 & 0.001\\
        100 & 0.102 & 0.002\\
    \bottomrule
    \end{tabular}
    \label{tab:vel_nm_sa}
    }
\end{figure}
\begin{figure}[h!]
    \centering
    \caption{Interpolazione lineare dati ottenuti con slitta carica senza alluminio}
    \subfloat[Grafico]{
        \label{fig:sm_na.png}
        \includegraphics[width=9.8cm]{sm_na.png}
    }
    \subfloat[Tabella]{
    \begin{tabular}{c|cc}
    \toprule
        $x_{intermedio}$&$\overline{v}$&$\sigma_{\overline{v}}$\\
        $[\si{cm}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
        50 & 0.0871 & 0.0003\\
        60 & 0.0850 & 0.0004\\
        70 & 0.0836 & 0.0003\\
        80 & 0.0809 & 0.0007\\
        90 & 0.0774 & 0.0007\\
        100 & 0.0748 & 0.0009\\
    \bottomrule
    \end{tabular}
    \label{tab:sm_na}
    }
\end{figure}

Si è utilizzato il metodo del minimo $\chi^2$ per calcolare il coefficiente angolare e l'intercetta della retta che meglio interpolasse le coppie di dati ($x_{intermedio}$, $v_{media}$) rappresentate nei grafici \ref{fig:nm_na.png}, \ref{fig:nm_sa.png}, \ref{fig:sm_na.png}. Al fine di correggere la stima di $g_0$ riportata nella discussione della prima esperienza è necessario un fattore correttivo, $\Delta g$, causato dalla presenza dell'attrito viscoso dell'aria, così stimato:
\begin{equation*}
   \Delta g=\frac{v_{med}\cdot \gamma}{sin(\alpha)}
\end{equation*}
dove $\gamma$ assume due valori differenti a seconda dei casi. Quando la slitta è scarica $\gamma$ è la media ponderata dei coefficienti angolari delle rette dei primi due campioni analizzati in questa seconda esperienza; quando la slitta è carica invece si utilizza il coefficiente angolare ottenuto con l'interpolazione lineare dei dati nel terzo campione. $\alpha$ rappresenta l'angolo di inclinazione della guida nei campioni considerati durante la prima esperienza e $v_{med}$ la velocità media (degli stessi campioni) così calcolata:

\begin{equation*}
    v_{med}=\frac{\overline{v}_{[40cm, 50cm]}+\overline{v}_{[100cm, 110cm]}}{2}
\end{equation*}

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c}
    \toprule
        Campione & Coeff. ang. $\times 10^{-5} [\si{s^{-1}}]$ & $\gamma \times 10^{-5} [\si{s^{-1}}]$\\
    \midrule
        No m., No All. &  $-6 \pm 1$ & \\ 
        No m., Sì All. & $-2 \pm 4$ & \multirow{-2}{*}{   $6 \pm 1$} \\
        \hline
        Sì m., No All. &  $-24 \pm 1$ & $24 \pm 1$\\
     \bottomrule
\end{tabular}
    \caption{Coefficienti angolari e stime di $\gamma$}
    \label{tab:stime_di_gamma}
\end{table}

Si è poi propagato l'errore relativo a $\sigma_{\Delta g}$, assumendo come $\sigma_{v_{med}}$ la propagazione degli errori delle velocità $v_{[40cm,50cm]}$ e $v_{[100cm,110cm]}$; come $\sigma_{\gamma}$ -- dividendo i casi analogamente a quanto detto per $\gamma$ -- il valore ottenuto dalla formula relativa all'errore della media ponderata presente nel paragrafo \ref{eq:errore_media_pond}; come $\sigma_{\alpha}$ si è utilizzata la deviazione standard ottenuta propagando l'errore sull'orizzontalità e l'errore ottenuto dalla distribuzione triangolare per il posizionamento della guida al relativo angolo considerato. Nella Tabella \ref{tab:deltag} sono riportati i valori ottenuti.


\begin{table}[h!]%DELTA G
    \centering
    \begin{tabular}{c|c|c}
        \toprule
        $\alpha$ & $\Delta g$ & $\sigma_{\Delta g}$ \\
        &$[\si{m/s^2}]$&$[\si{m/s^2}]$\\
        
    \midrule
    15' & 0.0028 & 0.0008 \\ 
    30' & 0.0020 & 0.0006 \\
    45' & 0.0016 & 0.0005 \\
    45' carica & 0.0016 & 0.0005 \\
 \bottomrule
    \end{tabular}
    \caption{Valori di $\Delta g \pm \sigma_{\Delta g}$}
    \label{tab:deltag}
\end{table}

In ultima fase si è calcolato $g=g_0 + \Delta g$ propagando il relativo errore da $\sigma_{g_{0}}$ e da $\sigma_{\Delta g}$. $g$ è stato confrontato con la compatibilità con $g_{PD}$. Tutti questi dati sono riportati in Tabella \ref{tab:stima_b_g}.\\

\begin{table}[h!]%G corretto g_0 e delta_g
    \centering
    \begin{tabular}{r|c|c|c|c}
    \toprule
    & \textbf{15'} & \textbf{30'} & \textbf{45'} & \textbf{45' con Massa}\\
    \midrule
        \textbf{Gravità $[\si{m/s^2}]$}       & 9.4\pm0.2$ & $9.5\pm0.2$ & $9.51\pm0.06$ & $9.7\pm0.1$ \\
      \textbf{Compatibilità $\lambda$} &1.7& 0.75& 4.3 & 0.09 $\\
        \bottomrule
    \end{tabular}
    \caption{Stime di gravità $g \pm \sigma_{g}$ (corretta con $\Delta g$) e relativa compatibilità $\lambda$ con $g_{PD}$}
    \label{tab:stima_b_g}
\end{table}

\section{Discussione dei risultati}
\subsection{Prima parte}
Una prima analisi delle deviazioni standard ottenute posizionando la guidovia a 15' evidenzia un andamento piuttosto crescente delle stesse fino all'intervallo [40cm-80cm], per poi subire una drastica diminuzione nell'intervallo [40cm-100cm] e, conseguentemente aumentare nuovamente. Tale comportamento lo si osserva anche negli altri 3 campioni. A questo punto dell'analisi non si è in grado di fornire una spiegazione al comportamento descritto.\\

Le premesse teoriche a base dell'esperienza concordano pienamente con i dati delle velocità medie di ogni intervallo di spazio di 10\si{cm}. Infatti, il moto che compie la slitta è riconducibile ad un moto uniformemente accelerato e, in conseguenza di ciò, come le evidenze sperimentali dimostrano, le velocità al trascorrere del tempo aumentano. L'espressione che determina matematicamente l'andamento della slitta, assumendo che essa stia compiendo un moto uniformemente accelerato, è $v=v_{0}+a\cdot t$. L'andamento di tale funzione è lineare, e ciò permette di considerare la velocità media di ogni intervallo di 0.1\si{m} come velocità istantanea nel tempo intermedio, consentendo di rappresentare graficamente le coppie di punti ($t_{intermedio}, v_{istantanea}$) con  le relative barre d'errore sulle ordinate.\\

Per il calcolo della deviazione standard delle velocità istantanee si è utilizzato, così come spiegato nell'analisi, la propagazione degli errori assumendo come errore casuale delle posizioni la deviazione standard derivante dalla distribuzione triangolare. Tale scelta è stata determinata dal fatto che si sta utilizzando una stecca metrica, strumento analogico in cui la percezione dell'occhio dell'operatore riesce a distinguere a quale tacca si avvicina di più il segno del traguardo. Essendo la più piccola tacca di misura pari ad un millimetro e il coefficiente affidabilità pari a 1, $\sigma_x$ nelle due posizioni è $\approx0.0004\si{m}$.\\
Nel calcolo di $\sigma_v$ è stato opportuno operare una differenza tra il primo intervallo ed i successivi: nel primo intervallo, [40cm-50cm], infatti, facendo riferimento alla formula \ref{eq:propagazione_velocità}, si è assunto pari a zero il quarto termine della somma del radicando in quanto esso non è definito; per tutti gli altri casi la formula non ha subito variazioni.

E' opportuna una considerazione sul termine di covarianza presente nella formula \ref{eq:teorema_varianze} utilizzata per il calcolo di $\sigma_v$. $cov(x_{i},x_{j})_{i \neq j}$  si è assunta pari a zero in quanto difficilmente calcolabile e ipotizzando che avrebbe di poco influenzato $\sigma_{v}$. Questa ipotesi è corroborata dal calcolo di $\sigma_{v, post}$ descritto dalla formula \ref{eq:y_posteriori}. Come viene verificato dal confronto dei $\sigma_{v, post}$ con i $\sigma_{v}$ riportati nelle tabelle \ref{tab:15_primi}, \ref{tab:30_primi}, \ref{tab:45_primi} e \ref{tab:d45_primi}. In particolare nell'assetto a 15' le prime tre $\sigma_{v}$ calcolate con il teorema delle varianze risultano essere minori rispetto a $\sigma_{v, post}$. Dalla quarta alla settima esse risultano invece maggiori. La stessa situazione si ripresenta anche nel campione di 45' con slitta carica.
\begin{wraptable}{l}{5cm}%Sigma a posteriori
\centering
    \begin{tabular}{c|c}
        \toprule
        $\alpha$ & $\sigma_{v, post}$ \\
        & $[\si{m/s^{2}}]$\\
        \midrule
        15' &  0.00204572\\
        30' & 0.00423992 \\
        45' & 0.00115392 \\
        45' carica & 0.00198645 \\
        \bottomrule
    \end{tabular}
    \caption{Calcolo $\sigma_{v, post}$}
    \label{tab:v_post}
\end{wraptable}

Questo comportamento è ciò che effettivamente ci si aspetta teoricamente, infatti, nelle misurazioni degli ultimi intervalli il tempo di esposizione della slitta a fattori influenzanti, quali l'attrito dell'aria o perturbazioni degli strumenti utilizzati, è maggiore rispetto alle misurazioni dei primi intervalli. Nel campione di 30' invece, le stime di $\sigma_{v}$ risultano essere sempre minori della stima a posteriori e a 45' invece sempre maggiori. Non si possono compiere altre inferenze su questo comportamento in quanto si necessita del termine di covarianza. In tutti i casi sopra esposti $\sigma_{v}$ e $\sigma_{v, post}$ si differenziano solamente per un termine di circa $10^{-4}\si{m/s}$ e ciò giustifica pienamente l'assunzione del termine di covarianza pari a zero.\\
Come riportato nell'analisi, si è utilizzato il metodo del minimo  ${\chi}^2$ per il calcolo della retta interpolante le coppie di dati a disposizione, ovvero velocità istantanea e tempo. Bisogna però precisare che si è assunta come grandezza da utilizzare sull'asse ascisse il tempo mentre per quella delle ordinate la velocità, in quanto affetta da errore casuale maggiore. Bisogna tener presente che nel metodo del minimo ${\chi}^{2}$ l'errore inevitabilmente presente nell'asse delle ascisse è stato assunto pari a zero, in quanto la sua considerazione avrebbe complicato il calcolo dell'interpolazione lineare. \\
Tenendo conto di tutte le considerazioni precedentemente effettuate, si sono calcolate le compatibilità delle stime di $g_0$ di tutti e 4 i campioni con l'accelerazione di gravità a Padova e si sono esposti i valori calcolati nella tabella \ref{tab:stima_b_g}. Si è riscontrato che la stima ottenuta dal terzo campione, ovvero con la guida inclinata di 45',risulta non compatibile; il primo campione invece di compatibilità discreta; il secondo ed il quarto campione invece risultano avere una compatibilità ottima.\\
La stima di $g_0$ effettuata con la slitta carica, con un inclinazione della guida a 45' è però più prossima a quella di Padova, in conclusione si ha che
\begin{equation*}
    g_0\pm\sigma_{g_0}=\left ( 9.7 \pm 0.1 \right ) m/s^{2}
\end{equation*}

\subsection{Seconda parte}
Dopo il calcolo delle medie e deviazioni standard associate alle misurazioni sperimentali, e al conseguente calcolo delle velocità medie di percorrenza, si è proceduto con il calcolo delle deviazioni standard ad esse associate. Si è scelto di calcolare $\sigma_{v}$ utilizzando la formula di propagazione degli errori, ipotizzando che $\Delta t$ e $\Delta s$ fossero statisticamente  indipendenti e di conseguenza, non analizzare il termine di covarianza. Tale ipotesi risulta essere avvalorata, ma non confermata dal calcolo di $\sigma_{v post}$. Infatti i due errori risultano essere molto simili come si deduce dalla tabella \ref{tab:v_post_delta_g}.

\begin{wraptable}{l}{5cm}%Sigma a posteriori
\centering
    \begin{tabular}{c|c}
        \toprule
        Campione & $\sigma_{v, post}$ \\
        & $[\si{m/s^{2}}]$\\
        \midrule
        No m., No All. &  0.0008\\
        No m., Sì All. & 0.001 \\
        Sì m., No All. & 0.0007 \\
        \bottomrule
    \end{tabular}
    \caption{Calcolo $\sigma_{v, post}$}
    \label{tab:v_post_delta_g}
\end{wraptable}

Per usare il metodo del ${\chi}^{2}$ si sono confrontati gli errori relativi alle due grandezze prese in considerazione: la posizione sulla guidovia e la velocità media in ciascun tratto. Si è riscontrato che gli errori sulla posizione risultano molto minori rispetto a quelli sulla velocità, giustificando l'utilizzo sull'asse delle $x$ la posizione e sull'asse delle $y$ la velocità; inoltre di assumere per l'interpolazione pari a zero l'errore sulle ascisse.\\
Per il calcolo dei coefficienti angolari si è utilizzato il metodo del minimo ${\chi}^{2}$, e come suggerisce la teoria essi risultano essere negativi. In questa esperienza non si è inclinata la guida, dunque l'accelerazione di gravità non influenzava il moto della slitta, nell'ipotesi della piena orizzontalità, dunque il moto del corpo risulta essere influenzato solamente da attrito viscoso dell'aria. Ciò comporta una diminuzione della velocità come si deduce anche dai grafici.\\
Si osserva però che tra i coefficienti angolari esiste una sostanziale differenza. Dapprima si può osservare che la massa influenza di molto il comportamento della slitta. Si ipotizza infatti che il nuovo assetto della  slitta riduca l'efficienza del cuscinetto d'aria creatosi sotto la stessa grazie al compressore, e che comporti una diminuzione della velocità a causa dell'episodico attrito radente generatosi tra la slitta e la guida. In seguito si osserva una differenza sostanziale tra i due campioni analizzati con la slitta scarica. Il secondo presenta un errore relativamente grande rispetto al secondo, e confrontando il dato con il grafico \ref{fig:nm_sa.png}, si ipotizzano imprecisioni durante la presa dati. Il calcolo della media ponderata dei coefficienti angolari ha in parte risolto questa incongruenza. Si sono ottenuti due valori di $\gamma$, riportai nella tabella \ref{tab:stime_di_gamma}.\\

Un confronto dei tre grafici \ref{fig:nm_na.png}, \ref{fig:nm_sa.png}, \ref{fig:sm_na.png} rivela un comportamento pressoché costane relativo alla velocità in funzione della posizione:  nell'intervallo tra 50 \si{cm} e 70\si{cm} si osserva che le velocità diminuiscono maggiormente rispetto a quanto stimato dalla retta interpolante, mentre nell'intervallo da 70 \si{cm} a 90\si{cm} subiscono una diminuzione minore di quanto ci si aspetti. Questa evidenza, riproponendosi in tutti i grafici suggerisce un'imperfezione sulla geometria della guida. Si pensa che in corrispondenza del primo tratto la guidovia sia leggermente in salita mentre nel secondo leggermente in discesa.\\
Come riportato nell'analisi è stato calcolato $\Delta_g$ ed è stato sommato a $g_0$ per compensare l'attrito dell'aria, al fine di stimare in modo più preciso $g$. Si è riscontrato che $\Delta g$ risultava ininfluente comparato a $g_0$ calcolato nell'analisi della prima esperienza e dunque ha di poco influenzato il risultato. La variazione evidente che invece si può riscontrare numericamente è sulla compatibilità tra i valori di $g \pm \sigma_{g}$ stimati e $g_{PD}\pm \sigma_{g_{PD}}$. Ciò ``e attribuibile sia al fatto che la miglior stima di $g$ sia più vicina a quella di $g_{PD}$ sia perché $\sigma_{g}$ è aumentato a causa della propagazione dovuta alla somma di $g_{0}$ e $\Delta g$.

\section{Margini di miglioramento}
 Nessuno. È già perfetta così. =)


\section{Conclusione}

L'obiettivo dell'esperienza è stato pienamente raggiunto, abbiamo utilizzato:
\begin{itemize}
    \item la combo potentissima "\textbf{PRESSOCHE' COSTANTE}"
    \item la parola \textbf{EPISODICO}
    \item abbiamo usato per la prima volta nella vita i trattini "--" con vero significato 
    \item ah, con una slitta di merda e un piano inclinato abbiamo stimato la gravità a Padova 
        \begin{equation*}
        g_0\pm\sigma_{g_0}=\left ( 9.79 \pm 0.01 \right ) m/s^{2}
        \end{equation*}
    \item richiesto al \textsc{NIST} di aggiungere un nuovo sottomultiplo: "\textit{'na merdina}" $\approx 10^{-5}$
    
\end{itemize}

\newpage
\section{Appendice}
\subsection{Formulario}
\textbf{Media, deviazione standard, deviazione standard della media}
\begin{equation*}
    \begin{aligned}
        \overline{x}&=\sum\limits_{i=1}^{N} \frac{x_{i}}{N}\\
        \sigma&=\sqrt{\frac{\sum\limits_{i=1}^{N} (x_{i}-\overline{x})}{N-1}}\\
        \sigma_{\overline{x}}&=\frac{\sigma}{\sqrt{N}}\\
    \end{aligned}
\end{equation*}\\

\textbf{Formula propagazione degli errori casuali}\\

Sia z=($x_1$,...;$x_N$) funzione di N variabili casuali $x_1$,...,$x_N$ e sia ${x_i^\ast}$=($x_1^\ast$,...,$x_N^{\ast}$) l'insieme di tutti i valori veri associati a tali variabili, si ha 
\begin{equation*}
    \sigma_z^{2}\approx  \sum_{i=j=1}^{N}\left ( \frac{\partial z}{\partial x_i}\Big|_{x_i^{\ast}} \right )^{2}\cdot\sigma_{x_i}^{2} +\sum_{i=1,j=1,i\neq j}^{N}\left (\frac{\partial z }{\partial x_i}\Big|_{x_i^{\ast}} \right ) \cdot \left ( \frac{\partial z}{\partial x_j} \Big|_{x_j^{\ast}} \right )\cdot cov(x_i,x_j)\label{eq:teorema_varianze}
\end{equation*}
E' stato utilizzato il simbolo $\approx$ in quanto si è scelto di troncare al primo termine lo sviluppo in serie di Taylor.\\


\textbf{Formula calcolo compatibilità}\\
\begin{equation*}
    \lambda=\frac{\left|a-b\right|}{\sqrt{\sigma^{2}_{a}+\sigma^{2}_{b}}}
\end{equation*}\\

\textbf{Formule per il ${\chi}^2$}
\begin{equation*}
        \begin{cases}
    a=&\frac{1}{\Delta}[(\sum\limits_{i=1}^{N}{x_{i}^{2}})\cdot(\sum\limits_{i=1}^{N}{y_{i}})-(\sum\limits_{i=1}^{N}{x_{i}})\cdot(\sum\limits_{i=1}^{N}{x_{i}y_{i}})] \\ 
    b=&\frac{1}{\Delta }\cdot \left [N\cdot \left ( \sum\limits_{i=1}^{N}x_i y_i \right )-\left ( \sum\limits_{i=1}^{N}x_i \right )\cdot \left ( \sum\limits_{i=1}^{N}y_i \right )  \right ]\\
    \Delta=& N\cdot \sum\limits_{i=1}^{N} x_i^{2} - \left ( \sum\limits_{i=1}^{N}x_i \right )^{2}\\

    \end{cases}
\end{equation*}

\begin{equation*}
    \begin{cases}
    \sigma_{a}=&\sigma_{y}\cdot\sqrt{\frac{\sum_{i=1}^{N}{x_{i}^{2}}}{\Delta}} \\
    \sigma_{b}=&\sigma_y\cdot \sqrt{\frac{N}{\Delta }}\\
    \end{cases}
\end{equation*}
\textbf{Sigma y a posteriori}
\begin{equation*}
    \sigma_{y, posteriori}=\sqrt{\frac{\sum_{i=1}^{N}(y-a-bx_{i})^{2}}{N-2}}\label{eq:y_posteriori}
\end{equation*}
\textbf{Media Ponderata}
\begin{equation*}\
    x_i=\frac{\sum_{i=1}^{N}\frac{x_i}{\sigma_{x_i}}}{\sum_{i=1}^{N}\frac{1}{\sigma_{x_i}}} \label{eq:media_ponderata}
\end{equation*}
\textbf{Errore Media Ponderata}
\begin{equation*}
     \sigma_{x_i}=\frac{1}{\sqrt{\sum_{i=1}^{N}\frac{1}{\sigma_{i}^{2}}}}\label{eq:errore_media_pond}
\end{equation*}
\subsection{Codice sorgente}
\paragraph{statistica.h} Libreria contenente alcune funzioni utilizzate nei programmi sottostanti.
\begin{lstlisting}[language=C++, label=lst:statistica.h, caption=statistica.h]
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath>
using namespace std;

//Funzione media
double media(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    if (fine != 0){
        double media_, counter_parz = 0, sum_parz = 0;
        for (int i = inizio; i < fine; i++){
            sum_parz = sum_parz + dati[i];
            counter_parz++;
        }
        media_ = sum_parz / counter_parz;
        return media_;
        if (log == "verbose") //log{
            cout << "Esecuzione media da " << inizio << " elemento a " << fine << "su vettore fornito" << endl;
        }
    }
    else if (fine == 0){
        double media_, sum = 0;
        for (auto c : dati){
            sum = sum + c;
        }
        media_ = sum / dati.size();
        return media_;
        if (log == "verbose"){
            cout << "Esecuzione media su tutto vettore fornito (" << media_ << ")" << endl;
        }
    }
}

//Funzione scarto quadratico medio (N a denominatore) (ex dstd_campione)
double squad_medio(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    double squad;
    double media_camp;
    double somma_camp;
    int counter = 0;

    if (fine != 0){
        media_camp = media(dati, inizio, fine);
        for (int j = inizio; j < fine; j++){
            somma_camp = somma_camp + (media_camp - dati[j]) * (media_camp - dati[j]);
            counter++;
        }
        squad = sqrt(somma_camp / counter);
        if (log == "verbose"){
            cout << "Scarto quadratico medio (S) (N a denominatore) su parte del vettore (" << squad << ")" << endl;
        }
    }
    else if (fine == 0){
        media_camp = media(dati);
        for (auto d : dati){
            somma_camp = somma_camp + (media_camp - d) * (media_camp - d);
        }
        counter = dati.size();
        squad = sqrt(somma_camp / counter);
        if (log == "verbose"){
            cout << "Scarto quadratico medio (S) (N a denominatore) su tutto il vettore (" << squad << ")" << endl;
        }
    }
    return squad;
}

//Funzione deviazione standard per popolazione (N-1 a denominatore)
double dstd(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    double dstd_camp;
    double media_camp;
    double somma_camp;
    int counter = 0;
    
    media_camp = media(dati, inizio, fine);
    if (fine != 0){
        for (int j = inizio; j < fine; j++){
            somma_camp = somma_camp + (media_camp - dati[j]) * (media_camp - dati[j]);
            counter++;
        }
        dstd_camp = sqrt(somma_camp / (counter - 1));
        if (log == "verbose"){
            cout << "Calcolo su parte del vettore di dev std(" << dstd_camp << ")" << endl;
        }
    }
    else if (fine == 0){
        for (auto c : dati){
            somma_camp = somma_camp + (media_camp - c) * (media_camp - c);
        }
        counter = dati.size();
        dstd_camp = sqrt(somma_camp / (counter - 1));
        if (log == "verbose"){
            cout << "Calcolo di dev std su tutto il vettore (" << dstd_camp << ")" << endl;
        }
    }
    return dstd_camp;
}

//Funzione deviazione standard della media
double dstd_media(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    double dstd_media_;
    if (fine != 0){
        dstd_media_ = dstd(dati, inizio, fine) / sqrt(fine - inizio);
        if (log == "verbose"){
            cout << "Calcolo deviazione standard della media su parte del vettore (" << dstd_media_ << ")" << endl;
        }
    }
    else if (fine == 0){
        dstd_media_ = dstd(dati) / sqrt(dati.size());
        if (log == "verbose"){
            cout << "Calcolo deviazione standard della media tutto il vettore (" << dstd_media_ << ")" << endl;
        }
    }
    return dstd_media_;
}

//Funzione che calcola la compatibilita' in uno stesso vettore specificando inizio e fine di ciascuno dei due intervalli (|a-b|/sqrt(sigma_a^2+sigma_b^2) )
double comp(vector<double> dati, int inizio_primo, int fine_primo, int inizio_secondo, int fine_secondo, string log = ""){
    double compatibility;
    double m_primo, m_secondo, dstd_primo, dstd_secondo;
    m_primo = media(dati, inizio_primo, fine_primo);
    m_secondo = media(dati, inizio_secondo, fine_secondo);
    dstd_primo = dstd_media(dati, inizio_primo, fine_primo);
    dstd_secondo = dstd_media(dati, inizio_secondo, fine_secondo);
    compatibility = (abs(m_primo - m_secondo) / sqrt(pow(dstd_primo, 2) + pow(dstd_secondo, 2)));
    if (log == "verbose"){
        cout << "Calcolo di compatibilita' fra due serie di valori consecutivi nel vettore (" << compatibility << ") ATTENZIONE CHE QUI SI DEVE USARE LA SIGMA RIFERITA ALLA MISURA" << endl;
    }
    return compatibility;
}

//Funzione che calcola la compatibilita' fra un sottoset di valori di un vettore e uno specifico valore di media e dev std sulla media forniti separatamente
double comp_2(vector<double> dati, int inizio, int fine, double media_ext, double dstd_media_ext, string log = ""){
    double compatibility;
    double media_vettore, dstd_media_vet;
    media_vettore = media(dati, inizio, fine);
    dstd_media_vet = dstd_media(dati, inizio, fine);
    compatibility = abs(media_vettore - media_ext) / sqrt(pow(dstd_media_vet, 2) + pow(dstd_media_ext, 2));
    if (log == "verbose"){
        cout << "Calcolo di compatibilita' fra parte di vettore vs. media e dstd media esterne (" << compatibility << ")" << endl;
    }
    return compatibility;
}

//Funzione che calcola l'ampiezza degli intervalli per istogramma dato un vettore e il numero di intervalli
double ampiezza_int(vector<double> dati, int num_int){
    double min = 1000.0, max = 0.0;
    for (auto x : dati){
        if (x < min)    min = x;
        if (x > max)    max = x;
    }
    return ((max - min) / num_int);
}

//Funzione per calcolo di delta
double delta(vector<double> dati_x, int inizio = 0, int fine = 0, string log = ""){
    double delta_;
    double size = 0;
    double sum_1 = 0, sum_2 = 0;
    if (fine == 0){
        size = dati_x.size();
        for (auto d : dati_x){
            sum_1 = sum_1 + pow(d, 2);
            sum_2 = sum_2 + d;
        }
        delta_ = size * sum_1 - pow(sum_2, 2);
        if (log == "verbose"){
            cout << "Calcolo di delta su tutto il vettore delle ascisse per chi quadro (" << delta_ << ")" << endl;
        }
    }
    else if (fine != 0){
        for (int i = inizio; i < fine; i++){
            size++;
            sum_1 = sum_1 + pow(dati_x.at(i), 2);
            sum_2 = sum_2 + dati_x.at(i);
        }
        delta_ = size * sum_1 - pow(sum_2, 2);
        if (log == "verbose"){
            cout << "Calcolo di delta su parte del vettore delle ascisse per chi quadro (" << delta_ << ")" << endl;
        }
    }
    return delta_;
}

//Funzione per calcolo di coefficiente a di y=a+bx (intercetta)
double a_intercetta(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double coeff_a;
    double delta_;
    double sum_1 = 0, sum_2 = 0, sum_3 = 0, sum_4 = 0;
    if (dati_y.size() != dati_x.size()){
        cout << "Dimensione di vettore per dati ascisse e' diversa da dimensione vettore dati ordinate" << endl;
    }
    if (fine == 0){
        for (int i = 0; i < dati_x.size(); i++){
            sum_1 = sum_1 + pow(dati_x.at(i), 2);
            sum_2 = sum_2 + dati_y.at(i);
            sum_3 = sum_3 + dati_x.at(i);
            sum_4 = sum_4 + (dati_x.at(i) * dati_y.at(i));
        }
        delta_ = delta(dati_x);
        coeff_a = (1 / delta_) * (sum_1 * sum_2 - sum_3 * sum_4);
        if (log == "verbose"){
            cout << "Calcolo di coeff a intercetta su tutti i valori dei vettori forniti (" << coeff_a << ")" << endl;
        }
    }
    else if (fine != 0){
        for (int i = inizio; i < fine; i++){
            sum_1 = sum_1 + pow(dati_x.at(i), 2);
            sum_2 = sum_2 + dati_y.at(i);
            sum_3 = sum_3 + dati_x.at(i);
            sum_4 = sum_4 + (dati_x.at(i) * dati_y.at(i));
        }
        delta_ = delta(dati_x, inizio, fine);
        coeff_a = (1 / delta_) * (sum_1 * sum_2 - sum_3 * sum_4);
        if (log == "verbose"){
            cout << "Calcolo di coeff a intercetta su alcuni valori dei vettori forniti (" << coeff_a << ")" << endl;
        }
    }
    return coeff_a;
}

//Funzione per calcolo di coefficiente b di y=a+bx (coeff. angolare)
double b_angolare(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double coeff_b;
    double delta_;
    int size = 0; 
    double sum_1 = 0, sum_2 = 0, sum_3 = 0;
    if (dati_y.size() != dati_x.size()){
        cout << "Dimensione di vettore per dati ascisse e' diversa da dimensione vettore dati ordinate";
    }
    if (fine == 0){
        for (int i = 0; i < dati_x.size(); i++){
            sum_1 = sum_1 + dati_x.at(i) * dati_y.at(i);
            sum_2 = sum_2 + dati_x.at(i);
            sum_3 = sum_3 + dati_y.at(i);
        }
        delta_ = delta(dati_x);
        size = dati_x.size();
        coeff_b = (1 / delta_) * (size * sum_1 - sum_2 * sum_3);
        if (log == "verbose"){
            cout << "Calcolo su tutti i valori del vettore (" << coeff_b << ")" << endl;
        }
    }
    else if (fine != 0){
        for (int i = inizio; i < fine; i++){
            sum_1 = sum_1 + dati_x.at(i) * dati_y.at(i);
            sum_2 = sum_2 + dati_x.at(i);
            sum_3 = sum_3 + dati_y.at(i);
            size++;
        }
        delta_ = delta(dati_x, inizio, fine);
        coeff_b = (1 / delta_) * (size * sum_1 - sum_2 * sum_3);
        if (log == "verbose"){
            cout << "Calcolo su parte dei valori del vettore (" << coeff_b << ")" << endl;
        }
    }
    return coeff_b;
}

//Funzione calcolo sigma y a posteriori
double sigma_y_posteriori(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double sigma_y;
    double a, b;
    int size = 0;
    double numeratore = 0;
    if (dati_x.size() != dati_y.size()){
        cout << "Vettori forniti non della stessa dimensione" << endl;
    }
    if (fine == 0){
        a = a_intercetta(dati_x, dati_y);
        b = b_angolare(dati_x, dati_y);
        size = dati_x.size();
        for (int i = 0; i < dati_x.size(); i++){
            numeratore = numeratore + pow((dati_y.at(i) - a - b * dati_x.at(i)), 2);
        }
        sigma_y = sqrt(numeratore / (size - 2));
    }
    else if (fine != 0){
        a = a_intercetta(dati_x, dati_y, inizio, fine);
        b = b_angolare(dati_x, dati_y, inizio, fine);
        for (int i = inizio; i < fine; i++){
            numeratore = numeratore + pow((dati_y.at(i) - a - b * dati_x.at(i)), 2);
            size++;
        }
        sigma_y = sqrt(numeratore / (size - 2));
    }
    return sigma_y;
}

//Funzione per calcolo di errore su coeff. a (intercetta)
double sigma_a(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double sigma_a_;
    double sigma_y;
    double delta_;
    double sum = 0;
    if (fine == 0){
        sigma_y = dstd(dati_y);
        delta_ = delta(dati_x);
        for (auto d : dati_x){
            sum = sum + pow(d, 2);
        }
        sigma_a_ = sigma_y * sqrt(sum / delta_);
        if (log == "verbose"){
            cout << "Calcolo su tutti i valori di vettori (" << sigma_a_ << ")" << endl;
        }
    }
    else if (fine != 0){
        sigma_y = dstd(dati_y, inizio, fine);
        delta_ = delta(dati_x, inizio, fine);
        for (int i = inizio; i < fine; i++){
            sum = sum + pow(dati_x.at(i), 2);
        }
        sigma_a_ = sigma_y * sqrt(sum / delta_);
        if (log == "verbose"){
            cout << "Calcolo su parte di valori di vettori (" << sigma_a_ << ")" << endl;
        }
    }
    return sigma_a_;
}

//Funzione per calcolo di errore su coeff. b (coeff. angolare)
double sigma_b(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double sigma_b_;
    double sigma_y;
    double delta_;
    int size = 0;
    if (fine == 0){
        sigma_y = dstd(dati_y);
        size = dati_x.size();
        delta_ = delta(dati_x);
        sigma_b_ = sigma_y * sqrt(size / delta_);
        if (log == "verbose"){
            cout << "Calcolo su tutti i valori di vettori (" << sigma_b_ << ")" << endl;
        }
    }
    else if (fine != 0){
        sigma_y = dstd(dati_y, inizio, fine);
        size = fine - inizio;
        delta_ = delta(dati_x, inizio, fine);
        sigma_b_ = sigma_y * sqrt(size / delta_);
        if (log == "verbose"){
            cout << "Calcolo su parte di valori di vettori (" << sigma_b_ << ")" << endl;
        }
    }
    return sigma_b_;
}
\end{lstlisting}

\paragraph{media.cxx} Programma utilizzato per l'analisi della prima parte utile al calcolo di media dei tempi, deviazione standard e deviazione standard della media per ciascun campione di misure. 
\begin{lstlisting}[language=C++, label=lst:media.cxx, caption=media.cxx]
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "statistica.h"
using namespace std;

int main(){
	int fine=40;
	double v;
	string fwrite, nomefile ;
	vector <string> fread;
	vector <double> valori;
	bool boolean=true;
	
	cout<<"Inserisci file di scrittura delle medie: ";
	cin>>fwrite;
	while(boolean){
		cout<<"Inserisci i file da cui leggere i dati: ";
		cin>>nomefile;
		fread.push_back(nomefile);
		cout<<"Inserisci 1 per continuare: ";
		cin>>boolean;
	}
	ofstream fout(fwrite);
	if(!fout){
		cout<<"Errore di scrittura su file";
		return 1;
	}
	fout<<"Inizio \tFine \tMedia \tDevStd \tDevStdMedia"<<endl;
	for(auto c:fread){
		ifstream fin(c);
		if(!fin){
			cout<<"Errore di lettura su file";
			return 1;
		}
		for(int i=0; i<5; i++){
			fin>>v;
			valori.push_back(v);
		}
		fine+=10;
		fout<<"40\t"<<fine<<"\t"<<media(valori)<<"\t"<<dstd(valori)<<"\t"<<dstd_media(valori)<<endl;
		for(int i=0; i<5; i++)	valori.pop_back();
	}
	return 0;
}
\end{lstlisting}

\paragraph{}
\begin{lstlisting}[language=C++, label=lst:, caption=]

\end{lstlisting}

\paragraph{seconda\_analisi.cxx} Programma adibito al calcolo delle velocità relative alle misurazioni ottenute nella seconda parte e dei relativi errori. Fornisce inoltre l'intercetta e il coefficiente angolare e i relativi errori.
\begin{lstlisting}[language=C++, label=lst:seconda_analisi.cxx, caption=seconda\_analisi.cxx]
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include "statistica.h"
using namespace std;

struct contenitore_statistico{
    double posizione_inizio = 0;
    double posizione_fine = 0;
    double posizione_intermedia = 0;
    double tempo_intermedio = 0;
    double media_tempo = 0;
    double dstd_tempo = 0;
    double dstd_tempo_media = 0;
    double media_vel = 0;
    double dstd_vel = 0;
    double dsts_vel_media = 0;
};

int main(){
    string angolo = "../Dati/SecondaParte/";
    string prefix;
    cout << "Inserisci prefisso file (nm_na_ nm_sa_ sm_na_): ";
    cin >> prefix;
    string extension = ".txt";
    const int numero_intervalli = 6;
    vector<contenitore_statistico> tempi(numero_intervalli);
    vector<contenitore_statistico> intervalli(numero_intervalli);
    double spazio = 0.2;
    double dstd_spazio = 0.001 / sqrt(6);

    for (int i = 0; i < numero_intervalli; i++){
        ifstream fin(angolo + prefix + to_string(40 + 10 * i) + "_" + to_string(60 + 10 * i) + extension);
        if (!fin){
            cout << "Errore lettura " << angolo + prefix + to_string(40 + 10 * i) + "_" + to_string(60 + 10 * i) + extension << endl;
        }

        double temp;
        vector<double> temp_time;
        while (fin >> temp){
            temp_time.push_back(temp);
        }
        tempi[i].posizione_inizio = 40 + 10 * i;
        tempi[i].posizione_fine = 60 + 10 * i;
        tempi[i].posizione_intermedia = (tempi[i].posizione_inizio + tempi[i].posizione_fine) / 2;
        tempi[i].media_tempo = media(temp_time);
        tempi[i].dstd_tempo = dstd(temp_time);
        tempi[i].dstd_tempo_media = dstd_media(temp_time);
        tempi[i].media_vel = spazio / tempi[i].media_tempo;
        tempi[i].dstd_vel =sqrt((2*(1/pow(tempi[i].media_tempo,2))*pow(dstd_spazio,2))+(0.2*0.2*(1/pow(tempi[i].media_tempo,4))*(pow(tempi[i].dstd_tempo_media,2))));
    }
    ofstream fdati("../Stat2/dati_grafico_" + prefix + ".txt");
    ofstream fchi("../Stat2/chi_" + prefix + ".txt");
    if (!fdati){
        cout << "Errore scrittura";
        return 1;
    }
    if (!fchi){
        cout << "Errore scrittura";
        return 1;
    }

    vector<double> posizione_x;
    vector<double> vel_y;
    cout << "DATI PER GRAFICO CON ERRORI VERTICALI" << endl;
    for (auto d : tempi){
        posizione_x.push_back(d.posizione_intermedia);
        vel_y.push_back(d.media_vel);
        cout << d.posizione_intermedia << "\t" << d.media_vel << "\t" << d.dstd_vel << endl;
        fdati << d.posizione_intermedia << "\t" << d.media_vel << "\t" << d.dstd_vel << endl;
    }

    cout << "ERRORI DI CHI QUADRO" << endl;
    cout << "A_intercetta: " << a_intercetta(posizione_x, vel_y) << "SIGMA_A: " << sigma_a(posizione_x, vel_y) << endl;
    cout << "B_Angolare: " << b_angolare(posizione_x, vel_y) << "SIGMA_B: " << sigma_b(posizione_x, vel_y) << endl;

    fchi << "A_intercetta: " << a_intercetta(posizione_x, vel_y) << "SIGMA_A: " << sigma_a(posizione_x, vel_y) << endl;
    fchi << "B_Angolare: " << b_angolare(posizione_x, vel_y) << "SIGMA_B: " << sigma_b(posizione_x, vel_y) << endl;
}
\end{lstlisting}

\end{document}*
