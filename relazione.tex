% !TeX encoding = utf8
% !TeX program = pdflatex
% !TeXpellcheck = it_IT

\documentclass[a4paper,11pt,oneside]{article} 

\usepackage{relazioni}
\usepackage{imakeidx}
\usepackage{colortbl}
\usepackage{booktabs}
\usepackage{blindtext}
\usepackage{titletoc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{geometry}
\usepackage{array}
\usepackage[export]{adjustbox}
\usepackage{multirow}
\usepackage{multicol}
\hypersetup{
%    colorlinks=false,
}


\def\titolo{Esperienza guidovia}
\def\dataconsegna{20 Gennaio 2020}

\graphicspath{{Figure/}}


\begin{document}
\input{Front-matter/Frontespizio}

\tableofcontents
\addtocontents{toc}{~\hfill{Pagina}\par}
\contentsmargin{6em}
\dottedcontents{section}[1em]{\bigskip}{2em}{1pc}
\dottedcontents{subsection}[3em]{\smallskip}{3em}{1pc}
\dottedcontents{subsubsection}[5em]{\smallskip}{4em}{1pc}


\newpage

\section{Obiettivo}
L'obiettivo dell'esperienza è ottenere la miglior stima dell'accelerazione di gravità a Padova, studiando il moto di una slitta su un piano inclinato.

\section{Apparato sperimentale}\label{section:apparato}

\begin{figure}[h!]
    \centering
    \includegraphics[width= 10cm]{DiagrammaApparato.jpg}
    \caption{Diagramma composizione apparato}
    \label{fig:apparato_sperimentale}
\end{figure}

Per lo svolgimento dell'esperienza si è fatto uso di:
\begin{enumerate}
    \item Una slitta in plexiglas rettangolare con delle sporgenze sulla parte inferiore al fine di agevolarne lo scorrimento sul piano inclinato. La slitta è eventualmente equipaggiabile con dischi di ottone per aumentarne la massa.
    \item Una guida in alluminio a sezione rettangolare e a inclinazione variabile (tramite una vite) sulla quale far scorrere la slitta. La guida è inoltre forata strategicamente su tutta la sua lunghezza per permettere l'uscita dell'aria erogata da un soffiatore a pressione regolabile. Ciò premette la conseguente formazione di un cuscino d'aria sotto la slitta durante la sua corsa al fine di eliminare il contributo dell'attrito radente.
    \item Un cronometro digitale avente sensibilità di $S=\num{1e4} \si{s^{-1}}$.
    \item Traguardi a sensori a infrarossi posizionati perpendicolarmente alla guida per delimitare una qualsiasi porzione di spazio sulla stessa e utilizzati per azionare e fermare il cronometro al passaggio della slitta. In particolare il primo permetteva l'inizio del conteggio, fermato poi dal passaggio della slitta al secondo traguardo.
    \item Elettrocalamita posta all'inizio della guida, utilizzata nella prima parte dell'esperienza per bloccare la slitta al fine di rilasciarla. Nella seconda parte è usata per imprimere una forza repulsiva alla slitta stessa. L'elettrocalamita è azionabile manualmente da un operatore.
    \item Spessori di alluminio utilizzati per ridurre la spinta impressa dall'elettrocalamita, interponibili tra quest'ultima e la slitta.
\end{enumerate}

\section{Metodo}
\subsection{Orizzontalità della guida}
La fase preliminare dell'esperienza prevede di determinare l'orizzontalità della guida tramite misurazioni dirette. La procedura impiegata consiste nel verificare se la slitta rimane stabile in 3 punti differenti, a 40 \si{cm}, 80 \si{cm} e 110 \si{cm} dall'origine della guida.\\
In primo luogo si è proceduto con l'accensione del soffiatore, impostato per tutta l'esperienza alla stessa potenza, per poi posizionare la slitta nel primo punto, a 40cm. Si è poi regolata la vite affinché la slitta rimanesse stabile al fine di poter fissare un sistema di riferimento con il quale testare l'orizzontalità sugli altri due punti. Lasciando invariato il sistema di riferimento sono stati annotati i valori sulla vite per i quali, nel secondo e nel terzo punto, la slitta rimane stabile.\\
Ipotizzando l'imprecisione delle misure precedentemente effettuate si è ripetuto il procedimento e si è verificato che per il secondo e per il terzo punto il risultato rimaneva invariato, invece per il primo punto si è misurato un nuovo valore. Data l'ipotesi, si è calcolata la media e la deviazione standard della media su queste ultime 3 misure effettuate.\\
La seguente tabella riporta i dati ottenuti:

\begin{table}[h!]
    \centering
    \caption{Valori per l'orizzontalità della guida \\ Unità di misura: quarti di giro di vite}
\begin{tabular}{ccc|cc}
    \toprule
    $\alpha_{0}$&$\alpha_{2}$&$\alpha_{3}$&$\overline{\alpha}$&$\sigma_{\overline{\alpha}}$\\
    \midrule
    0.15&0.15&0.40&0.23&0.08\\
    \bottomrule
    \end{tabular}
    \label{tab:guida_orizzontale}
\end{table}

Si è poi è assunto come zero del nuovo sistema di riferimento, la media delle misure $\overline{\alpha} \pm \sigma_{\overline{\alpha}}$, settando la ghiera.\\

\subsection{Presa dati prima esperienza}
Fissato il sistema di riferimento si è impostata la guida ad un'inclinazione di $15'$ ruotando 3 volte la vite, in quanto ciascun giro corrisponde ad una variazione di $5'$.\\
Si sono posizionati i traguardi, inizialmente a 40cm e 50cm e, successivamente, lasciando invariata la posizione del primo, si è spostato solo il secondo di 10cm per volta fino ad arrivare a 110cm. \\
Per ciascun intervallo di spazio ([40cm,50cm], [40cm,60cm], \dots [40cm,110cm]) si sono prese 5 misure ripetute di intervalli di tempo, ognuna delle quali rappresentava il tempo impiegato dalla slitta per percorrere il relativo spazio.\\  
Il cronometro è stato impostato per entrambe le esperienze alla sensibilità di $S = \num{1e4} \si{s^{-1}}$, in modo da rendere più accurata la successiva analisi.\\
Si è ripetuta la medesima operazione di presa dati variando l'inclinazione della slitta a 30' e successivamente a 45'.
Infine, operando sempre sulla slitta inclinata di 45', si è caricata la slitta con un disco di ottone al fine di incrementarne la massa.

\subsection{Presa dati seconda esperienza}
Si è portata la guida all'orizzontalità e l'elettrocalamita è stata configurata per imprimere una spinta alla slitta priva della massa di ottone. Ciò ha consentito alla slitta di procedere lungo la guida, rallentando per le forze d'attrito viscoso dell'aria, oggetto di analisi in questa seconda esperienza.\\
I traguardi sono stati posizionati rispettivamente a 40cm e 60cm, per poi modificarne la distanza dall'origine aumentandola di 10 cm per volta arrivando fino all'intervallo 90-110cm e, per ogni intervallo di spazio sono state prese 5 misurazioni temporali.\\
Si è poi ripetuto il procedimento e la conseguente presa dati, una volta con la slitta carica e una seconda volta con la slitta scarica utilizzando uno spessore di alluminio interposto tra quest'ultima e l'elettrocalamita.

\section{Analisi dati}
\subsection{Prima esperienza}
Si sono dapprima analizzate le misurazioni relative alla guida inclinata di 15' seguendo il procedimento riportato in seguito.\\
Per ciascun intervallo di spazio ([40cm, 50cm], [40cm, 60cm], \dots [40cm, 110cm]) si è calcolata la media $\overline{t}$, il suo relativo errore $\sigma_{\overline{t}}$ e la deviazione standard $\sigma$. Inoltre si sono calcolate le semisomme dei tempi medi tra coppie di intervalli consecutivi, ai quali d'ora in avanti si farà riferimento con il termine \textit{tempi intermedi}, e gli errori ad essi associati tramite la formula di propagazione degli errori (\ref{eq:prop_errori}).
I dati ottenuti sono riportati nella Tabella \ref{tab:15_primi}.

\begin{figure}[h!]
    \centering
    \subfloat[Medie tempi a 15']{
        \label{tab:15_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\
        \midrule
        40 & 50  & 0.642 & 0.003 & 0.001 \\
        40 & 60  & 1.191 & 0.002 & 0.001 \\
        40 & 70  & 1.692 & 0.005 & 0.002 \\
        40 & 80  & 2.143 & 0.009 & 0.004 \\
        40 & 90  & 2.557 & 0.008 & 0.003 \\
        40 & 100 & 2.944 & 0.003 & 0.001 \\
        40 & 110 & 3.315 & 0.006 & 0.002\\
        \bottomrule
    \end{tabular}
    \hspace{0.7cm}
    }
    \subfloat[Medie tempi a 30']{
        \label{tab:30_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\
        \midrule
        40 & 50  & 0.4528 & 0.0008 & 0.0003 \\
        40 & 60  & 0.8434 & 0.001  & 0.0007 \\
        40 & 70  & 1.1920 & 0.001  & 0.0006 \\
        40 & 80  & 1.513 & 0.002  & 0.001  \\
        40 & 90  & 1.8019 & 0.001  & 0.0007 \\
        40 & 100 & 2.0811 & 0.002  & 0.0009 \\
        40 & 110 & 2.338  & 0.002  & 0.001 \\
        \bottomrule
        \end{tabular}
    }
    \newline
    \subfloat[Medie tempi a 45']{
        \label{tab:45_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\
        \midrule
        40 & 50  & 0.3697  & 0.0004 & 0.0002 \\
        40 & 60  & 0.6892 & 0.001  & 0.0004 \\
        40 & 70  & 0.9755 & 0.001  & 0.0006 \\
        40 & 80  & 1.2364 & 0.0008 & 0.0003 \\
        40 & 90  & 1.4777 & 0.001  & 0.0007 \\
        40 & 100 & 1.7026 & 0.0009 & 0.0004 \\
        40 & 110 & 1.913 & 0.002  & 0.001 \\
        \bottomrule
    \end{tabular}
    \hspace{0.7cm}
    }
    \subfloat[Medie tempi a 45' con massa]{
        \label{tab:d45_primi}
    \begin{tabular}{m{0.7cm}m{0.7cm}|m{1.0cm}m{1.0cm}m{1.0cm}}
        \toprule
        Inizio&Fine&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
        $[\si{cm}]$&$[\si{cm}]$&$[\si{sec}]$&$[\si{sec}]$&$[\si{sec}]$\\\midrule
        40 & 50  & 0.37292 & 0.0002 & 0.00009 \\
        40 & 60  & 0.6915  & 0.0006 & 0.0002 \\
        40 & 70  & 0.9782 & 0.0003 & 0.0001 \\
        40 & 80  & 1.2389 & 0.001  & 0.0005 \\
        40 & 90  & 1.4787  & 0.001   & 0.0004 \\
        40 & 100 & 1.7025 & 0.0003 & 0.0001 \\
        40 & 110 & 1.9118 & 0.001  & 0.0005 \\
        \bottomrule
        \end{tabular}
    }
    \newline
    \caption{Medie tempi e deviazioni standard}
\end{figure}


Si è proceduto con il calcolo della velocità media per ogni intervallo di spazio di 10cm, partendo dall'intervallo [40cm,50cm] e terminando con l'intervallo [100cm,110cm] utilizzando la seguente formula:
\begin{equation*}
    \overline{v_{(x_i;x_{i+1})}}=\frac{x_{i+1}-x_i}{t(40;x_{i+1})-t(40;x_i)}
\end{equation*}
assumendo come valori di $x_i$ tutti i possibili estremi degli intervalli considerati, ovvero 40cm, 50cm, 60cm, ... , 110cm.
\newpage
Utilizzando la formula di propagazione degli errori si è poi calcolato l'errore casuale della velocità media per ogni intervallo, assumendo come errore sul tempo la deviazione standard della media di ciascun intervallo precedentemente calcolato, e come errore sullo spazio la deviazione standard relativa alla distribuzione triangolare, utilizzando le seguenti:

\begin{gather*}
\sigma_{x}=\frac{\mathopen|2\Delta x\mathclose|}{\sqrt{24}} \\
\label{eq:propagazione_velocità}
    \sigma_{v}= \sqrt{
   \left( {\frac{\partial v}{\partial x_{i}}} \Big|_{\ast}\right)^{2} \cdot \sigma_{x_{i}}^2  +   
   \left( {\frac{\partial v}{\partial x_{i+1}}}\Big|_{\ast}\right )^{2} \cdot \sigma_{x_{i+1}}^2   +   
   \left( {\frac{\partial v}{\partial t_{\left(40; x_{i+1}\right)}}}\Big|_{\ast}\right)^{2}  \cdot \sigma_{t_{\left(40; x_{i+1}\right)}}^2 +   
       \left( {\frac{\partial v}{\partial t_{\left(40; x_i\right)}}}\Big|_{\ast}\right)^{2} \cdot  \sigma_{t_{\left(40; x_i\right)}}^2
    }\\
    \text{Dove $2\Delta x$ è la più piccola tacca di misura leggibile dall'operatore sulla stecca metrica.}
\end{gather*}

Le coppie $(t_{intermedio}, v_{media})$ precedentemente calcolate sono state utilizzate come coordinate di punti su un piano cartesiano, e si è ricercata una loro interpolazione lineare sfruttando il metodo del minimo ${\chi}^2$, ottenendo il coefficiente angolare $b$, corrispondente alla componente dell'accelerazione di gravità $g_{0}$ sulla parallela alla guidovia, e l'intercetta della retta cercata, corrispondente alla velocità della slitta nella posizione iniziale, 40cm.\\
Per stimare $g_{0}$ è stato sufficiente dividere il coefficiente angolare della retta per il seno dell'angolo di inclinazione della guida. Per il computo di $ \sigma_{g_{0}}$ si è scelto di calcolare l'errore relativo all'angolo propagando gli errori dell'orizzontalità (Tabella \ref{tab:guida_orizzontale}) e l'errore derivante dalla distribuzione triangolare per l'incertezza del posizionamento a 15', il valore ottenuto risulta essere $0.1'$. L'errore relativo a $\sigma_b$  si è ricavato invece dal metodo del minimo ${\chi}^2$ per poi propagare $\sigma_b$ e $\sigma_{\alpha}$ tramite la formula \ref{eq:prop_errori}. Si è proceduto infine con il calcolo della compatibilità $\lambda$ delle 4 stime dell'accelerazione di gravità $g_{0}$ relative ai 4 differenti campioni con $g_{PD}=(9.801\pm 0.001)\si{m/s^2}$ stimata a Padova. Si è fatto riferimento alle seguenti per valutare $\lambda$ e la sua bontà:
\begin{equation*}%Comp
    \label{eq:cases}
    \begin{cases}
    0<\lambda\leq 1, & \text{Ottima}\\
    1<\lambda\leq2, & \text{Discreta}\\
    2<\lambda\leq3, & \text{Pessima}\\
    3<\lambda, & \text{Non compatibile}\\
    \end{cases}
\end{equation*}

In seguito tutto il procedimento è stato ripetuto variando l'inclinazione della guida portandola dapprima a 30', poi a 45' ed infine mantenendo l'inclinazione della guida a 45' si è aumentata la massa della slitta con un disco di ottone.\\

\begin{table}[h!]%b g_0 e comp
    \centering
    \begin{tabular}{r|c|c|c|c}
    \toprule
    & \textbf{15'} & \textbf{30'} & \textbf{45'} & \textbf{45' con Massa}\\
    \midrule
         \textbf{Accelerazione slitta $[\si{m/s^2}]$} & $0.04\pm0.01$    & $0.08\pm0.03$   & $0.12\pm0.05$    & $0.12\pm0.05$\\
        \textbf{Gravità $[\si{m/s^2}]$}       & $9.4\pm0.2$ & $9.5\pm0.2$ & $9.51\pm0.06$ & $9.7\pm0.1$ \\
        \textbf{Compatibilità $\lambda$} &1.7 &0.76 &4.3 &0.11\\
        \bottomrule
    \end{tabular}
    \caption{Stime di accelerazione $b\pm \sigma_{b}$, di gravità $g_{0} \pm \sigma_{g_{0}}$ e relativa compatibilità $\lambda$ con $g_{PD}$}
    \label{tab:stima_b_g}
\end{table}

\bigskip
In seguito vengono riportati i grafici affiancati dalle relative tabelle riguardanti le velocità calcolate:

\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 15'}
    \subfloat[Interpolazione lineare a 15']{
        \label{fig:g_0_15}
        \includegraphics[width=8.2cm]{15primi.png}
    }
    \subfloat[Medie e deviazioni standard a 15']{
    \label{tab:15primi}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.321 & 0.001 & 0.1557 & 0.0009 \\
    0.916 & 0.001 & 0.181 & 0.001 \\
    1.442 & 0.002 & 0.199 & 0.001 \\
    1.917 & 0.004 & 0.221 & 0.002 \\
    2.350 & 0.005 & 0.241 & 0.003 \\
    2.751 & 0.004 & 0.258 & 0.003 \\
    3.130 & 0.003 & 0.269 & 0.002 \\ 
    \bottomrule
    \end{tabular}
    }
\end{figure}


\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 30'}
    \subfloat[Interpolazione lineare a 30']{
    \label{fig:g_0_30}
           \includegraphics[width=8.2cm]{30primi.png}
    }
    \subfloat[Medie e deviazioni standard a 30']{
    \label{tab:30primi}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.2264 & 0.0003 & 0.220 & 0.001 \\
    0.6481 & 0.0008 & 0.256 & 0.001 \\
    1.017 & 0.001 & 0.286 & 0.001 \\
    1.352 & 0.001 & 0.311 & 0.002 \\
    1.657 & 0.001 & 0.346 & 0.002 \\
    1.941 & 0.001 & 0.358 & 0.002 \\
    2.209 & 0.001 & 0.388 & 0.003 \\
    \bottomrule
\end{tabular}
}
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 45'}
    \subfloat[Interpolazione lineare a 45']{
    \label{fig:g_0_45}
           \includegraphics[width=8.2cm]{45_primi.png}
    }
    \subfloat[Medie e deviazioni standard a 45']{
    \label{tab:45primi}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.18485 & 0.0002 & 0.270 & 0.001 \\
    0.52946 & 0.0005 & 0.312 & 0.001 \\ 
    0.83239 & 0.0007 & 0.349 & 0.002 \\ 
    1.10599 & 0.0007 & 0.383 & 0.002 \\ 
    1.35709 & 0.0008 & 0.414 & 0.002 \\
    1.5902 & 0.0008 & 0.444 & 0.003 \\
    1.808 & 0.001 & 0.473 & 0.003 \\
    \bottomrule
    \end{tabular}
    }
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Grafico e tabella relativi alle misure ottenute a 45' con massa}
    \subfloat[Interpolazione lineare a 45' con massa]{
    \label{fig:g_0_p45}
           \includegraphics[width=8.2cm]{45_primip.png}
    }
    \subfloat[Medie e dev. standard a 45' con massa]{
    \label{tab:45primi_p}
    \begin{tabular}{m{1.1cm}|m{1.1cm}|m{1cm}|m{1cm}}
    \toprule
    $t_{int}$ & $\sigma_t$ & $v_{ist}$ & $\sigma_v$ \\
    $[\si{s}]$&$[\si{s}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
    0.18646 & 0.00009 & 0.268 & 0.001 \\
    0.5322 & 0.0003 & 0.313 & 0.001 \\
    0.8348 & 0.0003 & 0.348 & 0.002 \\
    1.1086 & 0.0006 & 0.383 & 0.002 \\
    1.3588 & 0.0007 & 0.417 & 0.002 \\
    1.5906 & 0.0004 & 0.446 & 0.002 \\
    1.8072 & 0.0006 & 0.477 & 0.003 \\
    \bottomrule
\end{tabular}
}
\end{figure}
\newpage
\subsection{Seconda esperienza}
In primo luogo sono stati analizzati i valori derivanti dalle misurazioni ottenute con la slitta scarica e senza spessore di alluminio per ciascun segmento di 20cm ([40cm,60cm], [50cm,70cm], ...) al fine di calcolare media $\overline{t}$, la deviazione standard $\sigma$ e la deviazione standard della media $\sigma_{\overline{t}}$ dei tempi impiegati per percorrere la distanza fra i traguardi.\\

\begin{table}[h!]%NM_NA
\centering
\begin{tabular}{c|ccc}
\toprule
$x_{intermedio}$&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
$[\si{cm}]$&$[\si{s}]$&$[\si{s}]$&$[\si{s}]$\\
\midrule
50	&1.469	&0.01	&0.006\\
60	&1.486	    &0.01	&0.006\\
70	&1.50	&0.02	&0.01\\
80	&1.501	&0.01	&0.008\\
90	&1.493	&0.003	&0.001\\
100	&1.51	&0.03	&0.01\\
\bottomrule
\end{tabular}
    \caption{Medie tempi della slitta scarica senza spessore di alluminio}
    \label{tab:nm_na}
\end{table}

\begin{table}[h!]%SM_NA
\centering
\begin{tabular}{c|ccc}
\toprule
$x_{intermedio}$&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
$[\si{cm}]$&$[\si{s}]$&$[\si{s}]$&$[\si{s}]$\\
\midrule
50	&2.295 	&0.01	&0.008\\
60	&2.35	&0.02	&0.01\\
70	&2.391	&0.02	&0.009\\
80	&2.46     &0.04	&0.02\\
90  &2.58	&0.05	&0.02\\
100	&2.67	&0.07	&0.03\\
\bottomrule
\end{tabular}
    \caption{Medie tempi della slitta carica senza alluminio}
    \label{tab:sm_na}
\end{table}

\begin{table}[h!]%NM_SA
\centering
\begin{tabular}{c|ccc}
\toprule
$x_{intermedio}$&$\overline{t}$&$\sigma$&$\sigma_{\overline{t}}$\\
$[\si{cm}]$&$[\si{s}]$&$[\si{s}]$&$[\si{s}]$\\
\midrule
50	&1.87	&0.03	&0.01\\
60	&1.915	&0.01	&0.006\\
70	&1.90	&0.02	&0.01\\
80	&1.864	&0.01	&0.008\\
90	&1.86	&0.03	&0.01\\
100	&1.94	    &0.08	&0.03\\
\bottomrule
\end{tabular}
    \caption{Medie tempi della slitta scarica con alluminio}
    \label{tab:nm_sa}
\end{table}


Sono state poi calcolate le velocità di percorrenza $\overline{v}$ di ciascun tratto e il loro errore con la formula di propagazione degli errori, assumendo come $\sigma_{x}$ quella ottenuta dalla distribuzione triangolare, per le stesse motivazioni date nella prima esperienza.\\


\begin{figure}[h!]
    \centering 
    \caption{Interpolazione lineare dati ottenuti con slitta scarica senza alluminio}
    \subfloat[Grafico]{
    \label{fig:nm_na.png} \includegraphics[width=9.8cm]{nm_na.png}
    }
    \subfloat[Tabella]{
    \begin{tabular}{c|cc}
    \toprule
        $x_{intermedio}$&$\overline{v}$&$\sigma_{\overline{v}}$\\
        $[\si{cm}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
        50 & 0.1361 & 0.0006\\
        60 & 0.1345 & 0.0006\\
        70 & 0.133 & 0.001\\
        80 & 0.1331 & 0.0008\\
        90 & 0.1338 & 0.0002\\
        100 & 0.131 & 0.001\\
    \bottomrule
    \end{tabular}
    \label{tab:vel_nm_na}
    }
\end{figure}
\begin{figure}[h!]
    \centering
    \caption{Interpolazione lineare dati ottenuti con slitta scarica e alluminio}
    \subfloat[Grafico]{
    \label{fig:nm_sa.png}
           \includegraphics[width=9.8cm]{nm_sa.png}
    }
    \subfloat[Tabella]{
        \begin{tabular}{c|cc}
    \toprule
        $x_{intermedio}$&$\overline{v}$&$\sigma_{\overline{v}}$\\
        $[\si{cm}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
        50 & 0.1066 & 0.0007\\
        60 & 0.1044 & 0.0003\\
        70 & 0.1047 & 0.0006\\
        80 & 0.1072 & 0.0005\\
        90 & 0.107 & 0.001\\
        100 & 0.102 & 0.002\\
    \bottomrule
    \end{tabular}
    \label{tab:vel_nm_sa}
    }
\end{figure}
\begin{figure}[h!]
    \centering
    \caption{Interpolazione lineare dati ottenuti con slitta carica senza alluminio}
    \subfloat[Grafico]{
        \label{fig:sm_na.png}
        \includegraphics[width=9.8cm]{sm_na.png}
    }
    \subfloat[Tabella]{
    \begin{tabular}{c|cc}
    \toprule
        $x_{intermedio}$&$\overline{v}$&$\sigma_{\overline{v}}$\\
        $[\si{cm}]$&$[\si{m/s}]$&$[\si{m/s}]$\\
    \midrule
        50 & 0.0871 & 0.0003\\
        60 & 0.0850 & 0.0004\\
        70 & 0.0836 & 0.0003\\
        80 & 0.0809 & 0.0007\\
        90 & 0.0774 & 0.0007\\
        100 & 0.0748 & 0.0009\\
    \bottomrule
    \end{tabular}
    \label{tab:sm_na}
    }
\end{figure}

Si è utilizzato il metodo del minimo $\chi^2$ per calcolare il coefficiente angolare e l'intercetta della retta che meglio interpolasse le coppie di dati ($x_{intermedio}$, $v_{media}$) rappresentate nei grafici \ref{fig:nm_na.png}, \ref{fig:nm_sa.png}, \ref{fig:sm_na.png}. Al fine di correggere la stima di $g_0$ riportata nella discussione della prima esperienza è necessario un fattore correttivo, $\Delta g$, causato dalla presenza dell'attrito viscoso dell'aria, così stimato:
\begin{equation*}
   \Delta g=\frac{v_{med}\cdot \gamma}{sin(\alpha)}
\end{equation*}
dove $\gamma$ assume due valori differenti a seconda dei casi. Quando la slitta è scarica $\gamma$ è la media ponderata dei coefficienti angolari delle rette dei primi due campioni analizzati in questa seconda esperienza; quando la slitta è carica invece si utilizza il coefficiente angolare ottenuto con l'interpolazione lineare dei dati nel terzo campione. $\alpha$ rappresenta l'angolo di inclinazione della guida nei campioni considerati durante la prima esperienza e $v_{med}$ la velocità media (degli stessi campioni) così calcolata:

\begin{equation*}
    v_{med}=\frac{\overline{v}_{[40cm, 50cm]}+\overline{v}_{[100cm, 110cm]}}{2}
\end{equation*}

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c}
    \toprule
        Campione & Coeff. ang. & $\gamma$\\
        & $\times 10^{-5} [\si{s^{-1}}]$& $\times 10^{-5} [\si{s^{-1}}]$\\
    \midrule
        No m., No All. &  $-6 \pm 1$ & \\ 
        No m., Sì All. & $-2 \pm 4$ & \multirow{-2}{*}{   $6 \pm 1$} \\
        \hline
        Sì m., No All. &  $-24 \pm 1$ & $24 \pm 1$\\
     \bottomrule
\end{tabular}
    \caption{Coefficienti angolari e stime di $\gamma$}
    \label{tab:stime_di_gamma}
\end{table}

Si è poi propagato l'errore relativo a $\sigma_{\Delta g}$, assumendo come $\sigma_{v_{med}}$ la propagazione degli errori delle velocità $v_{[40cm,50cm]}$ e $v_{[100cm,110cm]}$; come $\sigma_{\gamma}$ -- dividendo i casi analogamente a quanto detto per $\gamma$ -- il valore ottenuto dalla formula relativa all'errore della media ponderata presente nel paragrafo \ref{eq:errore_media_pond}; come $\sigma_{\alpha}$ si è utilizzata la deviazione standard ottenuta propagando l'errore sull'orizzontalità e l'errore ottenuto dalla distribuzione triangolare per il posizionamento della guida al relativo angolo considerato. Nella Tabella \ref{tab:deltag} sono riportati i valori ottenuti.


\begin{table}[h!]%DELTA G
    \centering
    \begin{tabular}{c|c|c}
        \toprule
        $\alpha$ & $\Delta g$ & $\sigma_{\Delta g}$ \\
        &$[\si{m/s^2}]$&$[\si{m/s^2}]$\\
        
    \midrule
    15' & 0.0028 & 0.0008 \\ 
    30' & 0.0020 & 0.0006 \\
    45' & 0.0016 & 0.0005 \\
    45' carica & 0.0016 & 0.0005 \\
 \bottomrule
    \end{tabular}
    \caption{Valori di $\Delta g \pm \sigma_{\Delta g}$}
    \label{tab:deltag}
\end{table}

In ultima fase si è calcolato $g=g_0 + \Delta g$ propagando il relativo errore da $\sigma_{g_{0}}$ e da $\sigma_{\Delta g}$. $g$ è stato confrontato con la compatibilità con $g_{PD}$. Tutti questi dati sono riportati in Tabella \ref{tab:stima_b_g}.\\

\begin{table}[h!]%G corretto g_0 e delta_g
    \centering
    \begin{tabular}{r|c|c|c|c}
    \toprule
    & \textbf{15'} & \textbf{30'} & \textbf{45'} & \textbf{45' con Massa}\\
    \midrule
        \textbf{Gravità [\si{m/s^2}]}       & $9.4\pm0.2$ & $9.5\pm0.2$ & $9.51\pm0.06$ & $9.7\pm0.1$ \\
      \textbf{Compatibilità $\lambda$} &1.7& 0.75& 4.3 & 0.09 \\
        \bottomrule
    \end{tabular}
    \caption{Stime di gravità $g \pm \sigma_{g}$ (corretta con $\Delta g$) e relativa compatibilità $\lambda$ con $g_{PD}$}
    \label{tab:stima_b_g}
\end{table}

\begin{table}[h!]
\centering
    \begin{tabular}{c|c|c}
        \toprule
        $\alpha_{1}$& $\alpha_{2}$  & $\lambda$\\
        \midrule
        15'  &30'   &0.37\\
        15'  &45'   &0.26\\
        15'  &45' Carica &0.88\\
        30'  &45'   &0.25\\
        30'  &45' Carica &0.67\\
        45'  &45' Carica &2.1\\
        \bottomrule
    \end{tabular}
    \caption{Compatibilità tra le stime di $g$}
    \label{tab:compatibilita_d}
\end{table}
Si è infine calcolata la compatibilità $\lambda$ fra le varie stime di $g$ come viene riportato in Tabella \ref{tab:compatibilita_d}.

\section{Discussione dei risultati}
\subsection{Prima esperienza}
Le premesse teoriche a base dell'esperienza concordano pienamente con l'andamento dei dati delle velocità medie di ogni intervallo di spazio di $10\si{cm}$. Infatti, il moto che compie la slitta è riconducibile ad un moto uniformemente accelerato e, in conseguenza di ciò, come le evidenze sperimentali dimostrano, le velocità al trascorrere del tempo aumentano. L'espressione che determina matematicamente l'andamento della slitta, assumendo che essa stia compiendo un moto uniformemente accelerato, è $v=v_{0}+a\cdot t$. L'andamento di tale funzione è lineare, e ciò permette di considerare la velocità media di ogni intervallo di $0.1\si{m}$ come velocità istantanea nel tempo intermedio, consentendo di rappresentare graficamente le coppie di punti ($t_{intermedio}, v_{istantanea}$) con le relative barre d'errore sulle ordinate.\\
Per il calcolo della deviazione standard delle velocità istantanee si è utilizzato, così come spiegato nell'analisi, la propagazione degli errori assumendo come errore casuale delle posizioni la deviazione standard derivante dalla distribuzione triangolare. Tale scelta è stata determinata dal fatto che si sta utilizzando una stecca metrica, strumento analogico in cui la percezione dell'occhio dell'operatore riesce a distinguere a quale tacca si avvicina di più il segno del traguardo. Essendo la più piccola tacca di misura pari ad un millimetro e il coefficiente affidabilità pari a 1, $\sigma_x$ nelle due posizioni è $\approx0.0001\si{m}$.\\
Nel calcolo di $\sigma_v$ è stato opportuno operare una differenza tra il primo intervallo ed i successivi: nel primo intervallo, [40cm-50cm], infatti, facendo riferimento alla formula \ref{eq:propagazione_velocità}, si è assunto pari a zero il quarto termine della somma del radicando in quanto esso non è definito; per tutti gli altri casi la formula non ha subito variazioni.\\
E' opportuna una considerazione sul termine di covarianza presente nella formula \ref{eq:prop_errori} utilizzata per il calcolo di $\sigma_v$. $cov(x_{i},x_{j})_{i \neq j}$  si è assunta pari a zero in quanto difficilmente calcolabile e ipotizzando che avrebbe di poco influenzato $\sigma_{v}$. Questa ipotesi è corroborata dal calcolo di $\sigma_{v, post}$ descritto dalla formula \ref{eq:y_posteriori}. Come viene verificato dal confronto dei $\sigma_{v, post}$ con i $\sigma_{v}$ riportati nelle tabelle \ref{tab:15_primi}, \ref{tab:30_primi}, \ref{tab:45_primi} e \ref{tab:d45_primi}. In particolare nell'assetto a 15' le prime tre $\sigma_{v}$ calcolate con la formula di propagazione degli errori risultano essere minori rispetto a $\sigma_{v, post}$. Dalla quarta alla settima esse risultano invece maggiori. La stessa situazione si ripresenta anche nel campione di 45' con slitta carica.

\begin{wraptable}{l}{5cm}%Sigma a posteriori
\centering
    \begin{tabular}{c|c}
        \toprule
        $\alpha$ & $\sigma_{v, post}$ \\
        & $[\si{m/s^{2}}]$\\
        \midrule
        15' &  0.00204572\\
        30' & 0.00423992 \\
        45' & 0.00115392 \\
        45' carica & 0.00198645 \\
        \bottomrule
    \end{tabular}
    \caption{Calcolo $\sigma_{v, post}$}
    \label{tab:v_post}
\end{wraptable}
Questo comportamento è ciò che effettivamente ci si aspetta teoricamente, infatti, nelle misurazioni degli ultimi intervalli il tempo di esposizione della slitta a fattori influenzanti, quali l'attrito dell'aria o perturbazioni degli strumenti utilizzati, è maggiore rispetto alle misurazioni dei primi intervalli. Nel campione di 30' invece, le stime di $\sigma_{v}$ risultano essere sempre minori della stima a posteriori e a 45' invece sempre maggiori. Non si possono compiere altre inferenze su questo comportamento in quanto si necessita del termine di covarianza. In tutti i casi sopra esposti $\sigma_{v}$ e $\sigma_{v, post}$ si differenziano solamente per un termine di circa $10^{-4}\si{m/s}$ e ciò giustifica pienamente l'assunzione del termine di covarianza pari a zero.\\
Come riportato nell'analisi, si è utilizzato il metodo del minimo ${\chi}^2$ per il calcolo della retta interpolante le coppie di dati a disposizione, ovvero velocità istantanea e tempo. Bisogna però precisare che si è assunta come grandezza da utilizzare sull'asse ascisse il tempo mentre per quella sulle ordinate la velocità, in quanto affetta da errore casuale maggiore. Bisogna tener presente che nel metodo del minimo ${\chi}^{2}$ l'errore inevitabilmente presente nell'asse delle ascisse è stato assunto pari a zero, in quanto la sua considerazione avrebbe complicato il calcolo dell'interpolazione lineare.\\
Tenendo conto di tutte le considerazioni precedentemente effettuate, si sono calcolate le compatibilità delle stime di $g_0$ di tutti e 4 i campioni con l'accelerazione di gravità a Padova e si sono esposti i valori calcolati nella tabella \ref{tab:stima_b_g}. Si è riscontrato che la stima ottenuta dal terzo campione, ovvero con la guida inclinata di 45', risulta non compatibile; il primo campione invece ha compatibilità discreta; il secondo ed il quarto campione invece risultano avere una compatibilità ottima.\\
La compatibilità ottima del secondo campione è riconducibile al fatto che l'errore associato a $g_0$ abbia dimensioni considerevoli, ciò suggerisce quindi che la stima di $g_0$ effettuata con la slitta carica, con un inclinazione della guida a 45' è più prossima a quella di Padova. In conclusione si ha che
\begin{equation*}
    g_0\pm\sigma_{g_0}= \left(9.7\pm0.1 \right) \si{m/s^{2}}
\end{equation*}

\subsection{Seconda esperienza}
Dopo il calcolo delle medie e deviazioni standard associate alle misurazioni sperimentali, e al conseguente calcolo delle velocità medie di percorrenza, si è proceduto con il calcolo delle deviazioni standard ad esse associate. Si è scelto di calcolare $\sigma_{v}$ utilizzando la formula di propagazione degli errori, ipotizzando che $\Delta t$ e $\Delta s$ fossero statisticamente indipendenti e di conseguenza non analizzare il termine di covarianza. Tale ipotesi risulta essere avvalorata, ma non confermata, dal calcolo di $\sigma_{v post}$. Infatti i due errori risultano essere molto simili come si deduce dalla tabella \ref{tab:v_post_delta_g}.

\begin{wraptable}{l}{5cm}%Sigma a posteriori
\centering
    \begin{tabular}{c|c}
        \toprule
        Campione & $\sigma_{v, post}$ \\
        & $[\si{m/s^{2}}]$\\
        \midrule
        No m., No All. &  0.0008\\
        No m., Sì All. & 0.001 \\
        Sì m., No All. & 0.0007 \\
        \bottomrule
    \end{tabular}
    \caption{Calcolo $\sigma_{v, post}$}
    \label{tab:v_post_delta_g}
\end{wraptable}
Per usare il metodo del ${\chi}^{2}$ si sono confrontati gli errori relativi alle due grandezze prese in considerazione: la posizione sulla guidovia e la velocità media in ciascun tratto. Si è riscontrato che gli errori sulla posizione risultano molto minori rispetto a quelli sulla velocità, giustificando l'utilizzo sull'asse delle $x$ la posizione e sull'asse delle $y$ la velocità ed inoltre di assumere pari a zero l'errore sulle ascisse per l'interpolazione lineare.\\
L'utilizzo del metodo del minimo ${\chi}^{2}$ per il calcolo dei coefficienti angolari, ha rivelato che essi risultano essere negativi, come il modello teorico suggerisce. Infatti in questa esperienza non si è inclinata la guida, dunque l'accelerazione di gravità non influenzava il moto della slitta -- nell'ipotesi della piena orizzontalità -- pertanto il moto del corpo risulta essere influenzato solamente dall'attrito viscoso dell'aria. Ciò comporta una diminuzione della velocità come si deduce anche dai grafici.\\
Si osserva però che tra i coefficienti angolari esiste una sostanziale differenza. Dapprima si può osservare che la massa influenza di molto il comportamento della slitta. Si ipotizza infatti che il nuovo assetto riduca l'efficienza del cuscinetto d'aria creatosi sotto la stessa grazie al compressore, e che comporti una diminuzione della velocità a causa dell'episodico attrito radente generatosi tra la slitta e la guida. In seguito si osserva una differenza sostanziale tra i due campioni analizzati con la slitta scarica. Il secondo presenta un errore relativamente grande rispetto al primo, e confrontando il dato con il grafico \ref{fig:nm_sa.png}, si ipotizzano imprecisioni durante la presa dati. Il calcolo della media ponderata dei coefficienti angolari ha in parte risolto questa incongruenza. Si sono ottenuti due valori di $\gamma$, riportati nella tabella \ref{tab:stime_di_gamma}.\\
Un confronto dei tre grafici \ref{fig:nm_na.png}, \ref{fig:nm_sa.png}, \ref{fig:sm_na.png} rivela un comportamento pressoché costane relativo alla velocità in funzione della posizione: nell'intervallo tra 50 \si{cm} e 70\si{cm} si osserva che le velocità diminuiscono maggiormente rispetto a quanto stimato dalla retta interpolante, mentre nell'intervallo da 70 \si{cm} a 90\si{cm} subiscono una diminuzione minore di quanto ci si aspetti. Questa evidenza, riproponendosi in tutti i grafici suggerisce un'imperfezione sulla geometria della guida. Si pensa che in corrispondenza del primo tratto la guidovia sia leggermente in salita mentre nel secondo leggermente in discesa.\\
Come riportato nell'analisi è stato calcolato $\Delta g$ ed è stato sommato a $g_0$ per compensare l'attrito dell'aria, al fine di stimare in modo più preciso $g$. L'errore relativo a $g$, ovvero $\sigma_{g}$ è stato ottenuto con la formula di propagazione degli errori, in questo caso :

\begin{equation*}
      \sigma_{g}= \sqrt{
   \left( {\frac{\partial g}{\partial b}} \Big|_{\ast}\right)^{2} \cdot \sigma_{b}^2  +   
   \left( {\frac{\partial g}{\partial v_{med}}}\Big|_{\ast}\right )^{2} \cdot \sigma_{v_{med}}^2   +   
   \left( {\frac{\partial g}{\partial \gamma}}\Big|_{\ast}\right)^{2}  \cdot \sigma_{\gamma}^2 +   
    \left( {\frac{\partial g}{\partial \alpha}}\Big|_{\ast}\right)^{2} \cdot  \sigma_{\alpha}^2}
\end{equation*}

In alternativa sarebbe stato teoricamente possibile usare il teorema delle varianze ma, dato che il computo del termine di covarianza risultava difficoltoso, si è optato per la propagazione degli errori.\\

Si è riscontrato che $\Delta g$ risultava ininfluente comparato a $g_0$ e dunque ha di poco influenzato il risultato. La variazione evidente che invece si può riscontrare è la leggera diminuzione della compatibilità tra i valori di $g \pm \sigma_{g}$ stimati e $g_{PD}\pm \sigma_{g_{PD}}$. Ciò è attribuibile sia al fatto che la miglior stima di $g$ sia più vicina a quella di $g_{PD}$ sia perché $\sigma_{g}$ è aumentato a causa della propagazione dovuta alla somma di $g_{0}$ e $\Delta g$.\\
Inoltre si sono confrontati tra di loro i valori di $g$ ottenuti nei diversi campioni e, come si espone nella Tabella \ref{tab:compatibilita_d}, tutti i valori di $\lambda$ calcolati risultano essere < 1, tranne l'ultimo campione, che ha compatibilità pessima.
In base ai valori della compatibilità si è scelto di riportare come miglior stima di $g$ quella ottenuta dalla correzione di $g_0$ ottenuta nel campione analizzato a 45' con il disco di ottone:
\begin{gather*}
g= g_{0} + \Delta g =\SI{9.7}{m/s^{2}} + \SI{0.001}{m/s^{2}} = \SI{9.7}{m/s^{2}}\\
\sigma_g=\SI{0.1}{m/s^{2}}
\end{gather*}

\section{Margini di miglioramento}
Durante l'analisi dati e la discussione dei risultati sono stati individuati alcuni margini di miglioramento al fine di diminuire gli errori nelle misurazioni e ottenere delle migliori stime del valor vero di $g$ a Padova.

\paragraph{Orizzontalità della guida}

In principio all'esperienza, è stata calcolata l'orizzontalità della guida con solamente 3 misurazioni in 3 punti strategici della stessa. Maggiore precisione sul calcolo dell'orizzontalità si sarebbe potuta ottenere analizzando misure ripetute in più punti strategici della guida, tenendo conto anche della sua geometria imperfetta ipotizzata nella discussione della seconda esperienza.

\paragraph{Strumentazione}
Durante la presa dati della prima e della seconda esperienza, quando si è caricata la slitta, si è ipotizzato un episodico intervento dell'attrito radente tra la slitta e la guida. Si ipotizza che un aumento della potenza del compressore avrebbe fatto fronte a questo problema.\\
Inoltre, durante la presa dati della prima parte il pulsante tramite il quale l'elettrocalamita è attivata non veniva tenuto premuto durante il moto della slitta, causando una forza attrattiva sulla slitta che la rallentava. Tenendo premuto il pulsante durante tutto il moto della slitta, si sarebbe ottenuto un risultato più accurato.

\paragraph{Ambiente circostante}
I repentini spostamenti d'aria dovuti ai movimenti delle persone nel laboratorio hanno influito sulla stima delle velocità della slitta e sul conseguente calcolo del fattore correttivo $\Delta g$. Si pensa che se l'esperienza si ripetesse in ambiente privo di perturbazioni d'aria si otterrebbe un risultato decisamente più accurato.

\section{Conclusione}
L'obiettivo dell'esperienza è stato pienamente raggiunto. La miglior stima è stata ottenuta dal campione analizzato con la slitta carica e la guidovia inclinata di 45'. La correttezza di questa stima è stata determinata dalla alta compatibilità con $g_{PD}$. L'accelerazione di gravità stimata nell'esperienza risulta pertanto essere 

\begin{gather*}
  g=(9.7\pm0.1) \si{m/s^{2}}\\
\lambda_{g, g_{PD}}=0.098  
\end{gather*}

\newpage
\section{Appendice}
\subsection{Formulario}
\textbf{Media, deviazione standard, deviazione standard della media}
\begin{align*}
   % \begin{aligned}
        \overline{x}&=\sum\limits_{i=1}^{N} \frac{x_{i}}{N}&
        \sigma&=\sqrt{\frac{\sum\limits_{i=1}^{N} (x_{i}-\overline{x})}{N-1}}&
        \sigma_{\overline{x}}&=\frac{\sigma}{\sqrt{N}}
   % \end{aligned}
\end{align*}\\

\textbf{Formula di propagazione degli errori casuali}\\

Sia z=($x_1$,...;$x_N$) funzione di N variabili casuali $x_1$,...,$x_N$ e sia ${x_i^\ast}$=($x_1^\ast$,...,$x_N^{\ast}$) l'insieme di tutti i valori veri associati a tali variabili, si ha 

\begin{equation*}
    \sigma_z^{2}\approx  \sum_{i=j=1}^{N}\left ( \frac{\partial z}{\partial x_i}\Big|_{x_i^{\ast}} \right )^{2}\cdot\sigma_{x_i}^{2} +\sum_{i=1,j=1,i\neq j}^{N}\left (\frac{\partial z }{\partial x_i}\Big|_{x_i^{\ast}} \right ) \cdot \left ( \frac{\partial z}{\partial x_j} \Big|_{x_j^{\ast}} \right )\cdot cov(x_i,x_j)\label{eq:prop_errori}
\end{equation*}
E' stato utilizzato il simbolo $\approx$ in quanto si è scelto di troncare al primo termine lo sviluppo in serie di Taylor.\\


\textbf{Formula calcolo compatibilità}\\
\begin{equation*}
    \lambda=\frac{\left|a-b\right|}{\sqrt{\sigma^{2}_{a}+\sigma^{2}_{b}}}
\end{equation*}\\

\textbf{Formule per il ${\chi}^2$}
\begin{equation*}
        \begin{cases}
    a=&\frac{1}{\Delta}[(\sum\limits_{i=1}^{N}{x_{i}^{2}})\cdot(\sum\limits_{i=1}^{N}{y_{i}})-(\sum\limits_{i=1}^{N}{x_{i}})\cdot(\sum\limits_{i=1}^{N}{x_{i}y_{i}})] \\ 
    b=&\frac{1}{\Delta }\cdot \left [N\cdot \left ( \sum\limits_{i=1}^{N}x_i y_i \right )-\left ( \sum\limits_{i=1}^{N}x_i \right )\cdot \left ( \sum\limits_{i=1}^{N}y_i \right )  \right ]\\
    \Delta=& N\cdot \sum\limits_{i=1}^{N} x_i^{2} - \left ( \sum\limits_{i=1}^{N}x_i \right )^{2}\\

    \end{cases}
\end{equation*}

\begin{equation*}
    \begin{cases}
    \sigma_{a}=&\sigma_{y}\cdot\sqrt{\frac{\sum_{i=1}^{N}{x_{i}^{2}}}{\Delta}} \\
    \sigma_{b}=&\sigma_y\cdot \sqrt{\frac{N}{\Delta }}\\
    \end{cases}
\end{equation*}
\textbf{Sigma y a posteriori}
\begin{equation*}
    \sigma_{y, posteriori}=\sqrt{\frac{\sum_{i=1}^{N}(y-a-bx_{i})^{2}}{N-2}}\label{eq:y_posteriori}
\end{equation*}
\textbf{Media Ponderata}
\begin{equation*}\
    x_i=\frac{\sum_{i=1}^{N}\frac{x_i}{\sigma_{x_i}}}{\sum_{i=1}^{N}\frac{1}{\sigma_{x_i}}} \label{eq:media_ponderata}
\end{equation*}
\textbf{Errore Media Ponderata}
\begin{equation*}
     \sigma_{x_i}=\frac{1}{\sqrt{\sum_{i=1}^{N}\frac{1}{\sigma_{i}^{2}}}}\label{eq:errore_media_pond}
\end{equation*}
\subsection{Codice sorgente}
\paragraph{statistica.h} Libreria contenente alcune funzioni utilizzate nei programmi sottostanti.
\begin{lstlisting}[language=C++, label=lst:statistica.h, caption=statistica.h]
#include <iostream>
#include <string>
#include <vector>
#include <cmath>
#include <cctype>
using namespace std;

//Media
double media(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    if (fine != 0)    {
        double media_, counter_parz = 0, sum_parz = 0;
        for (int i = inizio; i < fine; i++){
            sum_parz = sum_parz + dati[i];
            counter_parz++;
        }
        media_ = sum_parz / counter_parz;
        return media_;
        if (log == "verbose"){
            cout << "Esecuzione media da " << inizio << " elemento a " << fine << "su vettore fornito" << endl;
        }
    }
    else if (fine == 0){
        double media_, sum = 0;
        for (auto c : dati){
            sum = sum + c;
        }
        media_ = sum / dati.size();
        return media_;
        if (log == "verbose")        {
            cout << "Esecuzione media su tutto vettore fornito (" << media_ << ")" << endl;
        }
    }
}

//Scarto quadratico medio (N a denominatore)
double squad_medio(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    double squad;
    double media_camp;
    double somma_camp;
    int counter = 0;

    if (fine != 0){
        media_camp = media(dati, inizio, fine);
        for (int j = inizio; j < fine; j++){
            somma_camp = somma_camp + (media_camp - dati[j]) * (media_camp - dati[j]);
            counter++;
        }
        squad = sqrt(somma_camp / counter);
        if (log == "verbose"){
            cout << "Scarto quadratico medio (S) (N a denominatore) su parte del vettore (" << squad << ")" << endl;
        }
    }
    else if (fine == 0){
        media_camp = media(dati);
        for (auto d : dati){
            somma_camp = somma_camp + (media_camp - d) * (media_camp - d);
        }
        counter = dati.size();
        squad = sqrt(somma_camp / counter);
        if (log == "verbose"){
            cout << "Scarto quadratico medio (S) (N a denominatore) su tutto il vettore (" << squad << ")" << endl;
        }
    }
    return squad;
}

//Deviazione standard per popolazione (N-1 a denominatore)
double dstd(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    double dstd_camp;
    double media_camp;
    double somma_camp;
    int counter = 0;
    media_camp = media(dati, inizio, fine);
    if (fine != 0){
        for (int j = inizio; j < fine; j++){
            somma_camp = somma_camp + (media_camp - dati[j]) * (media_camp - dati[j]);
            counter++;
        }
        dstd_camp = sqrt(somma_camp / (counter - 1));
        if (log == "verbose"){
            cout << "Calcolo su parte del vettore di dev std(" << dstd_camp << ")" << endl;
        }
    }
    else if (fine == 0){
        for (auto c : dati){
            somma_camp = somma_camp + (media_camp - c) * (media_camp - c);
        }
        counter = dati.size();
        dstd_camp = sqrt(somma_camp / (counter - 1));
        if (log == "verbose"){
            cout << "Calcolo di dev std su tutto il vettore (" << dstd_camp << ")" << endl;
        }
    }
    return dstd_camp;
}

//Deviazione standard della media
double dstd_media(vector<double> dati, int inizio = 0, int fine = 0, string log = ""){
    double dstd_media_;
    if (fine != 0){
        dstd_media_ = dstd(dati, inizio, fine) / sqrt(fine - inizio);
        if (log == "verbose"){
            cout << "D standard della media su parte del vettore (" << dstd_media_ << ")" << endl;
        }
    }
    else if (fine == 0){
        dstd_media_ = dstd(dati) / sqrt(dati.size());
        if (log == "verbose"){
            cout << "D standard della media tutto il vettore (" << dstd_media_ << ")" << endl;
        }
    }
    return dstd_media_;
}

//compatibilita' in uno stesso vettore con inizio e fine di ciascuno dei due intervalli
double comp(vector<double> dati, int inizio_primo, int fine_primo, int inizio_secondo, int fine_secondo, string log = ""){
    double compatibility;
    double m_primo, m_secondo, dstd_primo, dstd_secondo;
    m_primo = media(dati, inizio_primo, fine_primo);
    m_secondo = media(dati, inizio_secondo, fine_secondo);
    dstd_primo = dstd_media(dati, inizio_primo, fine_primo);
    dstd_secondo = dstd_media(dati, inizio_secondo, fine_secondo);
    compatibility = (abs(m_primo - m_secondo) / sqrt(pow(dstd_primo, 2) + pow(dstd_secondo, 2)));
    if (log == "verbose"){
        cout << "Calcolo di compatibilita' fra due serie di valori consecutivi nel vettore (" << compatibility << ") ATTENZIONE CHE QUI SI DEVE USARE LA SIGMA RIFERITA ALLA MISURA" << endl;
    }
    return compatibility;
}

//compatibilita' fra un sottoset di valori di un vettore e uno specifico valore fornito separatamente
double comp_2(vector<double> dati, int inizio, int fine, double media_ext, double dstd_media_ext, string log = ""){
    double compatibility;
    double media_vettore, dstd_media_vet;
    media_vettore = media(dati, inizio, fine);
    dstd_media_vet = dstd_media(dati, inizio, fine);
    compatibility = abs(media_vettore - media_ext) / sqrt(pow(dstd_media_vet, 2) + pow(dstd_media_ext, 2));
    if (log == "verbose")    {
        cout << "Calcolo di compatibilita' fra parte di vettore vs. media e dstd media esterne (" << compatibility << ")" << endl;
    }
    return compatibility;
}

//compatibilita' avendo due valori medi e i sigma relativi
double comp_3(double a, double b, double sigma_a, double sigma_b){
    return abs(a - b) / sqrt(pow(sigma_a, 2) + pow(sigma_b, 2));
}

//Ampiezza degli intervalli per istogramma dato un vettore e il numero di intervalli
double ampiezza_int(vector<double> dati, int num_int){
    double min = 1000.0, max = 0.0;
    for (auto x : dati){
        if (x < min)
            min = x;
        if (x > max)
            max = x;
    }
    return ((max - min) / num_int);
}

//Delta (chi-quadro)
double delta(vector<double> dati_x, int inizio = 0, int fine = 0, string log = ""){
    double delta_;
    double size = 0;
    double sum_1 = 0, sum_2 = 0;
    if (fine == 0){
        size = dati_x.size();
        for (auto d : dati_x){
            sum_1 = sum_1 + pow(d, 2);
            sum_2 = sum_2 + d;
        }
        delta_ = size * sum_1 - pow(sum_2, 2);
        if (log == "verbose"){
            cout << "Calcolo di delta su tutto il vettore delle ascisse per chi quadro (" << delta_ << ")" << endl;
        }
    }
    else if (fine != 0){
        for (int i = inizio; i < fine; i++){
            size++;
            sum_1 = sum_1 + pow(dati_x.at(i), 2);
            sum_2 = sum_2 + dati_x.at(i);
        }
        delta_ = size * sum_1 - pow(sum_2, 2);
        if (log == "verbose"){
            cout << "Calcolo di delta su parte del vettore delle ascisse per chi quadro (" << delta_ << ")" << endl;
        }
    }
    return delta_;
}

//Coefficiente a di y=a+bx (intercetta)
double a_intercetta(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double coeff_a;
    double delta_;
    double sum_1 = 0, sum_2 = 0, sum_3 = 0, sum_4 = 0;
    if (dati_y.size() != dati_x.size()){
        cout << "Dimensione di vettore per dati ascisse è diversa da dimensione vettore dati ordinate" << endl;
    }
    if (fine == 0){
        for (int i = 0; i < dati_x.size(); i++){
            sum_1 = sum_1 + pow(dati_x.at(i), 2);
            sum_2 = sum_2 + dati_y.at(i);
            sum_3 = sum_3 + dati_x.at(i);
            sum_4 = sum_4 + (dati_x.at(i) * dati_y.at(i));
        }
        delta_ = delta(dati_x);
        coeff_a = (1 / delta_) * (sum_1 * sum_2 - sum_3 * sum_4);
        if (log == "verbose"){
            cout << "Calcolo di coeff a intercetta su tutti i valori dei vettori forniti (" << coeff_a << ")" << endl;
        }
    }
    else if (fine != 0){
        for (int i = inizio; i < fine; i++){
            sum_1 = sum_1 + pow(dati_x.at(i), 2);
            sum_2 = sum_2 + dati_y.at(i);
            sum_3 = sum_3 + dati_x.at(i);
            sum_4 = sum_4 + (dati_x.at(i) * dati_y.at(i));
        }
        delta_ = delta(dati_x, inizio, fine);
        coeff_a = (1 / delta_) * (sum_1 * sum_2 - sum_3 * sum_4);
        if (log == "verbose"){
            cout << "Calcolo di coeff a intercetta su alcuni valori dei vettori forniti (" << coeff_a << ")" << endl;
        }
    }
    return coeff_a;
}

//Coefficiente b di y=a+bx (coeff. angolare)
double b_angolare(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double coeff_b;
    double delta_;
    int size = 0;
    double sum_1 = 0, sum_2 = 0, sum_3 = 0;
    if (dati_y.size() != dati_x.size()){
        cout << "Dimensione di vettore per dati ascisse è diversa da dimensione vettore dati ordinate";
    }
    if (fine == 0){
        for (int i = 0; i < dati_x.size(); i++){
            sum_1 = sum_1 + dati_x.at(i) * dati_y.at(i);
            sum_2 = sum_2 + dati_x.at(i);
            sum_3 = sum_3 + dati_y.at(i);
        }
        delta_ = delta(dati_x);
        size = dati_x.size();
        coeff_b = (1 / delta_) * (size * sum_1 - sum_2 * sum_3);
        if (log == "verbose"){
            cout << "Calcolo su tutti i valori del vettore (" << coeff_b << ")" << endl;
        }
    }
    else if (fine != 0){
        for (int i = inizio; i < fine; i++){
            sum_1 = sum_1 + dati_x.at(i) * dati_y.at(i);
            sum_2 = sum_2 + dati_x.at(i);
            sum_3 = sum_3 + dati_y.at(i);
            size++;
        }
        delta_ = delta(dati_x, inizio, fine);
        coeff_b = (1 / delta_) * (size * sum_1 - sum_2 * sum_3);
        if (log == "verbose"){
            cout << "Calcolo su parte dei valori del vettore (" << coeff_b << ")" << endl;
        }
    }
    return coeff_b;
}

//Sigma y a posteriori
double sigma_y_posteriori(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double sigma_y;
    double a, b;
    int size = 0;
    double numeratore = 0;
    if (dati_x.size() != dati_y.size()){
        cout << "Vettori forniti non della stessa dimensione" << endl;
    }
    if (fine == 0){
        a = a_intercetta(dati_x, dati_y);
        b = b_angolare(dati_x, dati_y);
        size = dati_x.size();
        for (int i = 0; i < dati_x.size(); i++){
            numeratore = numeratore + pow((dati_y.at(i) - a - b * dati_x.at(i)), 2);
        }
        sigma_y = sqrt(numeratore / (size - 2));
    }
    else if (fine != 0){
        a = a_intercetta(dati_x, dati_y, inizio, fine);
        b = b_angolare(dati_x, dati_y, inizio, fine);
        for (int i = inizio; i < fine; i++){
            numeratore = numeratore + pow((dati_y.at(i) - a - b * dati_x.at(i)), 2);
            size++;
        }
        sigma_y = sqrt(numeratore / (size - 2));
    }
    return sigma_y;
}

//Errore su coeff. a (intercetta)
double sigma_a(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double sigma_a_;
    double sigma_y;
    double delta_;
    double sum = 0;
    if (fine == 0){
        sigma_y = sigma_y_posteriori(dati_x, dati_y);
        delta_ = delta(dati_x);
        for (auto d : dati_x){
            sum = sum + pow(d, 2);
        }
        sigma_a_ = sigma_y * sqrt(sum / delta_);
        if (log == "verbose"){
            cout << "Calcolo su tutti i valori di vettori (" << sigma_a_ << ")" << endl;
        }
    }
    else if (fine != 0){
        sigma_y = sigma_y_posteriori(dati_x, dati_y, inizio, fine);
        delta_ = delta(dati_x, inizio, fine);
        for (int i = inizio; i < fine; i++){
            sum = sum + pow(dati_x.at(i), 2);
        }
        sigma_a_ = sigma_y * sqrt(sum / delta_);
        if (log == "verbose"){
            cout << "Calcolo su parte di valori di vettori (" << sigma_a_ << ")" << endl;
        }
    }
    return sigma_a_;
}

//Errore su coeff. b (coeff. angolare)
double sigma_b(vector<double> dati_x, vector<double> dati_y, int inizio = 0, int fine = 0, string log = ""){
    double sigma_b_p;
    double sigma_y;
    double delta_;
    int size = 0;
    if (fine == 0){
        sigma_y = sigma_y_posteriori(dati_x, dati_y);
        size = dati_x.size();
        delta_ = delta(dati_x);
        sigma_b_p = sigma_y * sqrt(size / delta_);
        if (log == "verbose"){
            cout << "Calcolo su tutti i valori di vettori (" << sigma_b_p << ")" << endl;
        }
    }
    else if (fine != 0){
        sigma_y = sigma_y_posteriori(dati_x, dati_y, inizio, fine);
        size = fine - inizio;
        delta_ = delta(dati_x, inizio, fine);
        sigma_b_p = sigma_y * sqrt(size / delta_);
        if (log == "verbose"){
            cout << "Calcolo su parte di valori di vettori (" << sigma_b_p << ")" << endl;
        }
    }
    return sigma_b_p;
}

//Media ponderata con errori
double media_ponderata(vector<double> valori, vector<double> errori, int inizio = 0, int fine = 0, string log = ""){
    double num = 0, den = 0;
    if (fine == 0){
        fine = valori.size();
    }
    if (valori.size() != errori.size()){
        cout << "dimensione di vettore valori non è uguale a quella di vettore errori" << endl;
        return 1;
    }
    for (int i = inizio; i < fine; i++){
        num += valori[i] * pow((1 / errori[i]), 2);
        den += pow((1 / errori[i]), 2);
    }
    if (log == "verbose"){
        cout << "Calcolo di valor vero tramite vettore di valori e vettori di errori" << endl;
    }
    return num / den;
}

//Errore medio (media ponderata)
double errore_v_vero(vector<double> errori){
    double sum = 0;
    for (auto d : errori){
        sum += pow((1 / d), 2);
    }
    return (1 / sqrt(sum));
}
\end{lstlisting}
\paragraph{media.cxx} Programma utilizzato per l'analisi della prima parte utile al calcolo di media dei tempi, deviazione standard e deviazione standard della media per ciascun campione di misure. 
\begin{lstlisting}[language=C++, label=lst:media.cxx, caption=media.cxx]
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "statistica.h"
using namespace std;

int main(){
	int fine=40;
	double v;
	string fwrite, nomefile ;
	vector <string> fread;
	vector <double> valori;
	bool boolean=true;
	
	cout<<"Inserisci file di scrittura delle medie: ";
	cin>>fwrite;
	while(boolean){
		cout<<"Inserisci i file da cui leggere i dati: ";
		cin>>nomefile;
		fread.push_back(nomefile);
		cout<<"Inserisci 1 per continuare: ";
		cin>>boolean;
	}
	ofstream fout(fwrite);
	if(!fout){
		cout<<"Errore di scrittura su file";
		return 1;
	}
	fout<<"Inizio \tFine \tMedia \tDevStd \tDevStdMedia"<<endl;
	for(auto c:fread){
		ifstream fin(c);
		if(!fin){
			cout<<"Errore di lettura su file";
			return 1;
		}
		for(int i=0; i<5; i++){
			fin>>v;
			valori.push_back(v);
		}
		fine+=10;
		fout<<"40\t"<<fine<<"\t"<<media(valori)<<"\t"<<dstd(valori)<<"\t"<<dstd_media(valori)<<endl;
		for(int i=0; i<5; i++)	valori.pop_back();
	}
	return 0;
}
\end{lstlisting}

\paragraph{seconda\_analisi.cxx} Programma adibito al calcolo delle velocità relative alle misurazioni ottenute nella seconda parte e dei relativi errori. Fornisce inoltre l'intercetta e il coefficiente angolare e i relativi errori.
\begin{lstlisting}[language=C++, label=lst:seconda_analisi.cxx, caption=seconda\_analisi.cxx]
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include "statistica.h"
using namespace std;

struct contenitore_statistico{
    double posizione_inizio = 0;
    double posizione_fine = 0;
    double posizione_intermedia = 0;
    double tempo_intermedio = 0;
    double media_tempo = 0;
    double dstd_tempo = 0;
    double dstd_tempo_media = 0;
    double media_vel = 0;
    double dstd_vel = 0;
    double dsts_vel_media = 0;
};

int main(){
    cout << "ATTENZIONE< ASSICURATI DI AVER CANCELLATO IL CONTENUTO DI ../Stat2/file_errori.txt altimenti si agginguno continuamente righe" << endl;
    string angolo = "../Dati/SecondaParte/";
    string prefix;
    cout << "Inserisci prefisso file (nm_na_ nm_sa_ sm_na_): ";
    cin >> prefix;
    string extension = ".txt";
    const int numero_intervalli = 6;                              //quanti intervalli di spazio ci sono per ogni set
    vector<contenitore_statistico> tempi(numero_intervalli);      //storage di tutte le info dei tempi dai file a stessa angolazione
    vector<contenitore_statistico> intervalli(numero_intervalli); //storage intervalli di tempo per ciascuno spazio e di velocita con relativi errori
    double spazio = 0.2;                                          //spazio fra due rilevatori
    double dstd_spazio = 0.001 / (2 * sqrt(6));                   //sigma spazio con ptl 1mm e deltax 0.5mm

    for (int i = 0; i < numero_intervalli; i++){
        ifstream fin(angolo + prefix + to_string(40 + 10 * i) + "_" + to_string(60 + 10 * i) + extension);
        if (!fin){
            cout << "Errore lettura " << angolo + prefix + to_string(40 + 10 * i) + "_" + to_string(60 + 10 * i) + extension << endl;
        }
        double temp;              //ausiliaria per il fin
        vector<double> temp_time; //vettore solo per leggere dai file
        while (fin >> temp){
            temp_time.push_back(temp);
        }
        tempi[i].posizione_inizio = 40 + 10 * i;
        tempi[i].posizione_fine = 60 + 10 * i;
        tempi[i].posizione_intermedia = (tempi[i].posizione_inizio + tempi[i].posizione_fine) / 2;
        tempi[i].media_tempo = media(temp_time);
        tempi[i].dstd_tempo = dstd(temp_time);
        tempi[i].dstd_tempo_media = dstd_media(temp_time);
        tempi[i].media_vel = spazio / tempi[i].media_tempo;
        tempi[i].dstd_vel = sqrt((2 * (1 / pow(tempi[i].media_tempo, 2)) * pow(dstd_spazio, 2)) + (pow(0.2, 2) * (1 / pow(tempi[i].media_tempo, 4)) * (pow(tempi[i].dstd_tempo_media, 2))));
    }
    ofstream fdati("../Stat2/dati_grafico_" + prefix + ".txt");
    ofstream fchi("../Stat2/chi_" + prefix + ".txt");
    if (!fdati){
        cout << "Errore scrittura";
        return 1;
    }
    if (!fchi){
        cout << "Errore scrittura";
        return 1;
    }

    vector<double> posizione_x;
    vector<double> vel_y;
    vector<double> errori_perce_v;
    vector<double> errori_v;
    cout << "DATI PER GRAFICO CON ERRORI VERTICALI" << endl;
    for (auto d : tempi){
        posizione_x.push_back(d.posizione_intermedia);
        vel_y.push_back(d.media_vel);
        errori_v.push_back(d.dstd_vel);
        errori_perce_v.push_back((d.dstd_vel / d.media_vel) * 100);
        cout << d.posizione_intermedia << "\t" << d.media_vel << "\t" << d.dstd_vel << endl;
        fdati << d.posizione_intermedia << "\t" << d.media_vel << "\t" << d.dstd_vel << endl;
    }
    double sigma_v_posteriori;
    sigma_v_posteriori = sigma_y_posteriori(posizione_x, vel_y);
    cout << "err post vel, err vel" << endl;
    for (auto d : tempi){
        if (sigma_v_posteriori > d.dstd_vel){
            cout << sigma_v_posteriori << "\t>\t" << d.dstd_vel << endl;
        }
        else if (sigma_v_posteriori < d.dstd_vel){
            cout << sigma_v_posteriori << "\t<\t" << d.dstd_vel << endl;
        }
        else{
            cout << sigma_v_posteriori << "\t=\t" << d.dstd_vel << endl;
        }
    }
    cout << "IN REALTA È: " << media(errori_v) << " RISPETTO A POST:" << sigma_v_posteriori << endl;
    cout << "Err vel e err spazio" << endl;
    for (auto d : tempi){
        if (d.dstd_vel > dstd_spazio){
            cout << d.dstd_vel << "\t>\t" << dstd_spazio << endl;
        }
        else if (d.dstd_vel < dstd_spazio){
            cout << d.dstd_vel << "\t<\t" << dstd_spazio << endl;
        }
        else{
            cout << d.dstd_vel << "\t=\t" << dstd_spazio << endl;
        }
    }
    cout << "MEDIA PERCETUALE DI ERRORI: " << media(errori_perce_v) << endl;
    cout << "ERRORI DI CHI QUADRO" << endl;
    cout << "A_intercetta: " << a_intercetta(posizione_x, vel_y) << "\tSIGMA_A: " << sigma_a(posizione_x, vel_y) << endl;
    cout << "B_Angolare: " << b_angolare(posizione_x, vel_y) << "\tSIGMA_B: " << sigma_b(posizione_x, vel_y) << endl;
    fchi << a_intercetta(posizione_x, vel_y) << "\t" << sigma_a(posizione_x, vel_y) << endl;
    fchi << b_angolare(posizione_x, vel_y) << "\t" << sigma_b(posizione_x, vel_y) << endl;
    ofstream error_file;
    error_file.open("../Stat2/file_errori.txt", std::ios_base::app);
    error_file << b_angolare(posizione_x, vel_y) << "\t" << sigma_b(posizione_x, vel_y) << endl;
}
\end{lstlisting}

\paragraph{media_ponderata.cxx} Programma per il calcolo del coefficiente angolare $\gamma$.
\begin{lstlisting}[language=C++, label=lst:, caption=]
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <math.h>
#include "statistica.h"
using namespace std;

int main(){
    string massa;
    cout << "Massa? (si/no): ";
    cin >> massa;
    if (massa == "si"){
        string b, sigma_coeff_b;
        ifstream fin("../Stat2/sm_chi.txt");
        if (!fin){
            cout << "Errore lettura";
            return 1;
        }
        fin >> b >> sigma_coeff_b;
        cout << "COEFF ATTRITO" << endl;
        cout << b << " +/- " << sigma_coeff_b << endl;
    }
    else if (massa == "no"){
        double b_, sigma_coeff_b_;
        vector<double> b;
        vector<double> sigma_coeff_b;
        ifstream fin("../Stat2/nm_chi.txt");
        if (!fin){
            cout << "Errore lettura";
            return 1;
        }
        while (fin >> b_ >> sigma_coeff_b_){
            b.push_back(b_);
            sigma_coeff_b.push_back(sigma_coeff_b_);
        }
        cout << "COEFF ATTRITO" << endl;
        cout << media_ponderata(b, sigma_coeff_b) << " +/- ";
        cout << errore_v_vero(sigma_coeff_b) << endl;
    }
    return 0;
}
\end{lstlisting}

\paragraph{delta_g.cxx} Programma per la stima di $g_0$, $\Delta g$ e dei relativi errori.
\begin{lstlisting}[language=C++, label=lst:, caption=]
#include <iostream>
#include <cmath>
#include <fstream>
#include <string>
#include <vector>
#include "statistica.h"
using namespace std;
double prop_g_0(double a, double sigma_a_x, double alfa, double sigma_alfa);
double prop_delta_g(double angolo, double sigma_angolo, double v_med, double sigma_v_med, double gamma, double sigma_gamma);
double prop_g(double a_x, double sigma_a_x, double angolo, double sigma_angolo, double lambda, double sigma_lambda, double v_x, double sigma_v_x);

int main(){
	vector<double> vel;
	vector<double> err_vel;
	double v_med, sigma_v_med, delta_g, sigma_delta_g, angolo, sigma_gamma, sigma_gamma_massa, gamma, gamma_massa, sigma_angolo, g_0, sigma_g_0, g, sigma_g, a_x, sigma_a_x;
	string fwrite, fread;
	sigma_angolo = 3.029e-05;
	sigma_angolo = sqrt(pow(sigma_angolo, 2) + pow(M_PI / (38880 * 2 * sqrt(24)), 2));
	double g_pd = 9.801;
	double sigma_g_pd = 0.001;

	cout << "Inserire il postfisso di lettura, stat__.txt ";
	cin >> fread;
	ifstream fin("../Stat/PerLatex/stat" + fread + "__con_colonna_inizio_e_fine_.txt");
	if (!fin){
		cout << "Errore lettura file";
		return 1;
	}
	int index = 0;
	double t;
	while (fin >> t){
		if (index == 4){
			vel.push_back(t);
			index++;
		}
		if (index == 5){
			err_vel.push_back(t);
			index = 0;
		}
		else
			index++;
	}
	v_med = (vel[0] + vel[6]) / 2.;											 //vmedia (v[40-50]+v[100-110]/2)
	sigma_v_med = (1 / 2) * (sqrt(pow(err_vel[0], 2) + pow(err_vel[6], 2))); //errore su v_med con propagazione

	//da media ponderata
	gamma = 6.07214e-05;
	sigma_gamma = 1.83687e-05;
	gamma_massa = 0.00024894;
	sigma_gamma_massa = 1.71628e-05;

	//calcolo deltag, g, compatibilita
	if (fread == "15"){
		angolo = 0.25;
		a_x = 0.041252;
		sigma_a_x = 0.00082973;
		g_0 = a_x / sin((angolo * M_PI) / 180);
		sigma_g_0 = prop_g_0(a_x, sigma_a_x, angolo, sigma_angolo);
		delta_g = (gamma * v_med) / sin((angolo * M_PI) / 180);
		sigma_delta_g = prop_delta_g(angolo, sigma_angolo, v_med, sigma_v_med, gamma, sigma_gamma);
		g = g_0 + delta_g;
		sigma_g = prop_g(a_x, sigma_a_x, angolo, sigma_angolo, gamma, sigma_gamma, v_med, sigma_v_med);
		cout << "g_0:\t" << g_0 << "+/-" << sigma_g_0 << endl;
		cout << "d_g:\t" << delta_g << "+/-" << sigma_delta_g << endl;
		cout << "g=g_0+delta_g:\t" << g << "+/-" << sigma_g << endl;
		cout << "Compatibilita con g_pd di g_0:\t" << comp_3(g_0, g_pd, sigma_g_0, sigma_g_pd) << endl;
		cout << "Compatibilita con g_pd di g:\t" << comp_3(g, g_pd, sigma_g, sigma_g_pd) << endl;
	}
	if (fread == "30"){
		angolo = 0.5;
		a_x = 0.0836481;
		sigma_a_x = 0.00243711;
		g_0 = a_x / sin((angolo * M_PI) / 180);
		sigma_g_0 = prop_g_0(a_x, sigma_a_x, angolo, sigma_angolo);
		delta_g = (gamma * v_med) / sin((angolo * M_PI) / 180);
		sigma_delta_g = prop_delta_g(angolo, sigma_angolo, v_med, sigma_v_med, gamma, sigma_gamma);
		g = g_0 + delta_g;
		sigma_g = prop_g(a_x, sigma_a_x, angolo, sigma_angolo, gamma, sigma_gamma, v_med, sigma_v_med);
		cout << "g_0:\t" << g_0 << "+/-" << sigma_g_0 << endl;
		cout << "d_g:\t" << delta_g << "+/-" << sigma_delta_g << endl;
		cout << "g=g_0+delta_g:\t" << g << "+/-" << sigma_g << endl;
		cout << "Compatibilita con g_pd di g_0:\t" << comp_3(g_0, g_pd, sigma_g_0, sigma_g_pd) << endl;
		cout << "Compatibilita con g_pd di g:\t" << comp_3(g, g_pd, sigma_g, sigma_g_pd) << endl;
	}
	if (fread == "45"){
		angolo = 0.75;
		a_x = 0.124508;
		sigma_a_x = 0.000809781;
		g_0 = a_x / sin((angolo * M_PI) / 180);
		sigma_g_0 = prop_g_0(a_x, sigma_a_x, angolo, sigma_angolo);
		delta_g = (gamma * v_med) / sin((angolo * M_PI) / 180);
		sigma_delta_g = prop_delta_g(angolo, sigma_angolo, v_med, sigma_v_med, gamma, sigma_gamma);
		g = g_0 + delta_g;
		sigma_g = prop_g(a_x, sigma_a_x, angolo, sigma_angolo, gamma, sigma_gamma, v_med, sigma_v_med);
		cout << "g_0:\t" << g_0 << "+/-" << sigma_g_0 << endl;
		cout << "d_g:\t" << delta_g << "+/-" << sigma_delta_g << endl;
		cout << "g=g_0+delta_g:\t" << g << "+/-" << sigma_g << endl;
		cout << "Compatibilita con g_pd di g_0:\t" << comp_3(g_0, g_pd, sigma_g_0, sigma_g_pd) << endl;
		cout << "Compatibilita con g_pd di g:\t" << comp_3(g, g_pd, sigma_g, sigma_g_pd) << endl;
	}
	if (fread == "d45"){
		angolo = 0.75;
		a_x = 0.128128;
		sigma_a_x = 0.00139633;
		g_0 = a_x / sin((angolo * M_PI) / 180);
		sigma_g_0 = prop_g_0(a_x, sigma_a_x, angolo, sigma_angolo);
		delta_g = (gamma * v_med) / sin((angolo * M_PI) / 180);
		sigma_delta_g = prop_delta_g(angolo, sigma_angolo, v_med, sigma_v_med, gamma, sigma_gamma);
		g = g_0 + delta_g;
		sigma_g = prop_g(a_x, sigma_a_x, angolo, sigma_angolo, gamma, sigma_gamma, v_med, sigma_v_med);
		cout << "g_0:\t" << g_0 << "+/-" << sigma_g_0 << endl;
		cout << "d_g:\t" << delta_g << "+/-" << sigma_delta_g << endl;
		cout << "g=g_0+delta_g:\t" << g << "+/-" << sigma_g << endl;
		cout << "Compatibilita con g_pd di g_0:\t" << comp_3(g_0, g_pd, sigma_g_0, sigma_g_pd) << endl;
		cout << "Compatibilita con g_pd di g:\t" << comp_3(g, g_pd, sigma_g, sigma_g_pd) << endl;
	}
	return 0;
}

double prop_delta_g(double angolo, double sigma_angolo, double v_med, double sigma_v_med, double gamma, double sigma_gamma){
	double sig;
	double dp_gamma, dp_v_x, dp_angolo, angolo_rad;
	angolo_rad = angolo * M_PI / 180;
	dp_gamma = v_med / sin(angolo_rad);
	dp_v_x = gamma / sin(angolo_rad);
	dp_angolo = v_med * gamma * cos(angolo_rad) / pow(sin(angolo_rad), 2);
	sig = sqrt(pow(dp_v_x * sigma_v_med, 2) + pow(dp_angolo * sigma_angolo, 2) + pow(dp_gamma * sigma_gamma, 2));
	return sig;
}
double prop_g_0(double a_x, double sigma_a_x, double angolo, double sigma_angolo){
	double sig;
	double angolo_rad = angolo * M_PI / 180;
	sig = sqrt(pow((sigma_a_x / sin(angolo_rad)), 2) + pow(((a_x * cos(angolo_rad) * sigma_angolo) / (pow(sin(angolo_rad), 2))), 2));
	return sig;
}
double prop_g(double a_x, double sigma_a_x, double angolo, double sigma_angolo, double lambda, double sigma_lambda, double v_x, double sigma_v_x){
	double prop_gg;
	double dp_a_x, dp_angolo, dp_lambda, dp_v_x, angolo_rad;
	angolo_rad = angolo * M_PI / 180;
	dp_a_x = 1. / sin(angolo_rad);
	dp_lambda = v_x / sin(angolo_rad);
	dp_v_x = lambda / sin(angolo_rad);
	dp_angolo = (cos(angolo_rad) / pow(sin(angolo_rad), 2)) * (a_x + lambda * v_x);
	prop_gg = sqrt(pow((dp_a_x * sigma_a_x), 2) + pow((dp_lambda * sigma_lambda), 2) + pow((dp_v_x * sigma_v_x), 2) + pow((dp_angolo * sigma_angolo), 2));
	return prop_gg;
}
\end{lstlisting}

\subsection{Dati Grezzi}
\subsubsection{Prima Parte}
\begin{figure}[h!]
    \centering
    \caption{Misurazioni a 15'}
    \label{fig:dati_grezzi}
    \subfloat[40-50]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
                0.6469\\
                0.6422\\
                0.6388\\
                0.6391\\
                0.6436\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-60]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
                1.1916\\
                1.1918\\
                1.1903\\
                1.1887\\
                1.1965\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-70]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.6834\\
            1.6934\\
            1.6940\\
            1.6952\\
            1.6966\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-80]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.1356\\
            2.1406\\
            2.1429\\
            2.1591\\
            2.1376\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-90]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.5530\\
            2.5655\\
            2.5638\\
            2.5454\\
            2.5619\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-100]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.9461\\
            2.9483\\
            2.9414\\
            2.9406\\
            2.9470\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-110]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            3.3078\\
            3.3251\\
            3.3157\\
            3.3119\\
            3.3177\\
            \bottomrule
        \end{tabular}
    }
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Misurazioni a 30'}
    \label{fig:dati_grezzi}
    \subfloat[40-50]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.4522\\
            0.4542\\
            0.4532\\
            0.4526\\
            0.4520\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-60]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.8441\\
            0.8462\\
            0.8424\\
            0.8416\\
            0.8430\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-70]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.1903\\
            1.1938\\
            1.1917\\
            1.1910\\
            1.1933\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-80]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.5118\\
            1.5148\\
            1.5162\\
            1.5145\\
            1.5089\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-90]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.8041\\
            1.8018\\
            1.7999\\
            1.8027\\
            1.8012\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-100]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.0794\\
            2.0806\\
            2.0828\\
            2.0838\\
            2.0792\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-110]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.3376\\
            2.3348\\
            2.3379\\
            2.3392\\
            2.3420\\
            \bottomrule
        \end{tabular}
    }
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Misurazioni a 45'}
    \label{fig:dati_grezzi}
    \subfloat[40-50]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.3695\\
0.3694\\
0.3692\\
0.3704\\
0.3700\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-60]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.6885\\
            0.6901\\
            0.6888\\
            0.6905\\
            0.6882\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-70]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.9768\\
            0.9772\\
            0.9754\\
            0.9744\\
            0.9740\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-80]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.2352\\
            1.2358\\
            1.2370\\
            1.2368\\
            1.2373\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-90]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.4805\\
            1.4762\\
            1.4772\\
            1.4775\\
            1.4774\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-100]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.7032\\
            1.7030\\
            1.7032\\
            1.7028\\
            1.7010\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-110]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.9116\\
            1.9153\\
            1.9106\\
            1.9170\\
            1.9152\\
            \bottomrule
        \end{tabular}
    }
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Misurazioni a 45' con massa}
    \label{fig:dati_grezzi}
    \subfloat[40-50]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.3727\\
            0.3728\\
            0.3732\\
            0.3731\\
            0.3728\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-60]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.6922\\
            0.6922\\
            0.6912\\
            0.6909\\
            0.6910\\

            \bottomrule
        \end{tabular}
    }
    \subfloat[40-70]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            0.9777\\
            0.9784\\
            0.9782\\
            0.9788\\
            0.9782\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-80]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.2402\\
            1.2402\\
            1.2392\\
            1.2374\\
            1.2378\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-90]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.4792\\
            1.4773\\
            1.4780\\
            1.4794\\
            1.4796\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-100]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.7022\\
            1.7031\\
            1.7027\\
            1.7024\\
            1.7023\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[40-110]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.9102\\
            1.9110\\
            1.9132\\
            1.9131\\
            1.9119\\
            \bottomrule
        \end{tabular}
    }
\end{figure}

\newpage
\subsubsection{Seconda Parte}

\begin{figure}[h!]
    \centering
    \caption{Misurazioni senza massa e senza alluminio}
    \label{fig:dati_grezzi}
    \subfloat[40-60]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.4558\\
1.4758\\
1.4617\\
1.4917\\
1.4616\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[50-70]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
1.5053\\
1.4938\\
1.4829\\
1.4666\\
1.4839\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[60-80]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.4758\\
1.5280\\
1.5036\\
1.5240\\
1.4774\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[70-90]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.5220\\
1.4790\\
1.4880\\
1.4970\\
1.5218\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[80-100]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.4902\\
1.4926\\
1.4908\\
1.4960\\
1.4996\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[90-110]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.4895\\
1.5186\\
1.5477\\
1.5526\\
1.4822\\
            \bottomrule
        \end{tabular}
    }
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Misurazioni con massa e senza alluminio}
    \label{fig:dati_grezzi}
    \subfloat[40-60]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.8366\\
1.8514\\
1.9024\\
1.8888\\
1.9007\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[50-70]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
1.9190\\
1.9157\\
1.9268\\
1.9234\\
1.8920\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[60-80]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.9331\\
1.9036\\
1.9245\\
1.9139\\
1.8706\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[70-90]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.8776\\
1.8425\\
1.8881\\
1.8662\\
1.8490\\

            \bottomrule
        \end{tabular}
    }
    \subfloat[80-100]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.8439\\
1.8940\\
1.9023\\
1.8706\\
1.8070\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[90-110]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            1.9974\\
1.8682\\
1.8768\\
1.9044\\
2.0682\\
            \bottomrule
        \end{tabular}
    }
\end{figure}

\begin{figure}[h!]
    \centering
    \caption{Misurazioni senza massa e con alluminio}
    \label{fig:dati_grezzi}
    \subfloat[40-60]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.3101\\
2.3080\\
2.2704\\
2.3078\\
2.2822\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[50-70]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.3455\\
2.3385\\
2.3282\\
2.3902\\
2.3557\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[60-80]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.4144\\
2.3765\\
2.3994\\
2.4028\\
2.3637\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[70-90]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.5364\\
2.4156\\
2.4404\\
2.4572\\
2.4994\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[80-100]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.6152\\
2.5586\\
2.5077\\
2.5896\\
2.6486\\
            \bottomrule
        \end{tabular}
    }
    \subfloat[90-110]{
        \begin{tabular}{c}
            \toprule
            \textbf{t [s]}\\
            \midrule
            2.6887\\
2.7009\\
2.6727\\
2.7544\\
2.5500\\
            \bottomrule
        \end{tabular}
    }
\end{figure}

\end{document}*
